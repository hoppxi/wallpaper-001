// src/core/color.ts
function rgbToHex(r, g, b) {
  const toHex = (c) => {
    const hex = c.toString(16);
    return hex.length === 1 ? "0" + hex : hex;
  };
  return "#" + toHex(r) + toHex(g) + toHex(b);
}
function hexToRgb(hex) {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(
    hex
  );
  return {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  };
}
function rgbaToHex(r, g, b, a) {
  return rgbToHex(r, g, b) + Math.round(a * 255).toString(16).padStart(2, "0");
}
function hexToRgba(hex, a) {
  const rgb = hexToRgb(hex);
  return rgb ? `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${a})` : null;
}
function colorBrightness(color) {
  const rgb = hexToRgb(color);
  return rgb ? (0.299 * rgb.r + 0.587 * rgb.g + 0.114 * rgb.b) / 255 : null;
}
function colorContrast(color1, color2) {
  const brightness1 = colorBrightness(color1);
  const brightness2 = colorBrightness(color2);
  if (brightness1 !== null && brightness2 !== null) {
    return Math.abs(brightness1 - brightness2);
  }
  return null;
}
function generateRandomColor() {
  const randomColorComponent = () => Math.floor(Math.random() * 256);
  return rgbToHex(
    randomColorComponent(),
    randomColorComponent(),
    randomColorComponent()
  );
}
function darkenColor(color, percentage) {
  const { r, g, b } = hexToRgb(color);
  const factor = 1 - percentage / 100;
  const newR = Math.floor(r * factor);
  const newG = Math.floor(g * factor);
  const newB = Math.floor(b * factor);
  return rgbToHex(newR, newG, newB);
}
function lightenColor(color, percentage) {
  const { r, g, b } = hexToRgb(color);
  const factor = 1 + percentage / 100;
  const newR = Math.min(Math.floor(r * factor), 255);
  const newG = Math.min(Math.floor(g * factor), 255);
  const newB = Math.min(Math.floor(b * factor), 255);
  return rgbToHex(newR, newG, newB);
}
function calculateLuminance(color) {
  const { r, g, b } = hexToRgb(color);
  return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
}
function hslToRgb(hue, saturation, lightness) {
  const h = hue / 360;
  const s = saturation / 100;
  const l = lightness / 100;
  const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
  const p = 2 * l - q;
  const rgb = {
    r: Math.round(hueToRgb(p, q, h + 1 / 3) * 255),
    g: Math.round(hueToRgb(p, q, h) * 255),
    b: Math.round(hueToRgb(p, q, h - 1 / 3) * 255)
  };
  return rgb;
}
function hueToRgb(p, q, t) {
  if (t < 0) t += 1;
  if (t > 1) t -= 1;
  if (t < 1 / 6) return p + (q - p) * 6 * t;
  if (t < 1 / 2) return q;
  if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
  return p;
}
function rgbToHsl(red, green, blue) {
  const r = red / 255;
  const g = green / 255;
  const b = blue / 255;
  const max = Math.max(r, g, b);
  const min = Math.min(r, g, b);
  const delta = max - min;
  let h, s, l;
  if (delta === 0) {
    h = 0;
  } else if (max === r) {
    h = (g - b) / delta % 6;
  } else if (max === g) {
    h = (b - r) / delta + 2;
  } else {
    h = (r - g) / delta + 4;
  }
  h = Math.round((h * 60 + 360) % 360);
  l = (max + min) / 2;
  s = delta === 0 ? 0 : delta / (1 - Math.abs(2 * l - 1));
  s = Math.round(s * 100);
  l = Math.round(l * 100);
  return { h, s, l };
}
function mixColors(color1, color2, weight) {
  const rgb1 = hexToRgb(color1);
  const rgb2 = hexToRgb(color2);
  const mixedColor = {
    r: Math.round(rgb1.r * weight + rgb2.r * (1 - weight)),
    g: Math.round(rgb1.g * weight + rgb2.g * (1 - weight)),
    b: Math.round(rgb1.b * weight + rgb2.b * (1 - weight))
  };
  return rgbToHex(mixedColor.r, mixedColor.g, mixedColor.b);
}
function generateColorGradient(startColor, endColor, steps) {
  const gradient = [];
  for (let i = 0; i < steps; i++) {
    const weight = i / (steps - 1);
    const interpolatedColor = mixColors(startColor, endColor, weight);
    gradient.push(interpolatedColor);
  }
  return gradient;
}
function invertColor(color) {
  const { r, g, b } = hexToRgb(color);
  const invertedColor = {
    r: 255 - r,
    g: 255 - g,
    b: 255 - b
  };
  return rgbToHex(invertedColor.r, invertedColor.g, invertedColor.b);
}

// src/modules/color.ts
var Color = {
  calculateLuminance,
  brightness: colorBrightness,
  contrast: colorContrast,
  darken: darkenColor,
  generateGradient: generateColorGradient,
  generateRandom: generateRandomColor,
  hexToRgb,
  hexToRgba,
  hslToRgb,
  hueToRgb,
  invert: invertColor,
  lighten: lightenColor,
  mix: mixColors,
  rgbToHex,
  rgbToHsl,
  rgbaToHex
};
var color_default = Color;

// node_modules/@butility/network/network.js
async function ajaxFetch(options) {
  const config = {
    method: options.method,
    headers: options.headers,
    body: options.method !== "GET" ? formatDataForFetch(options.data, options.headers) : void 0,
    signal: options.abortSignal
  };
  try {
    const response = await fetch(options.url, config);
    const responseBody = await handleFetchResponse(
      response,
      options.responseType
    );
    if (options.success) options.success(responseBody);
  } catch (error) {
    handleError(options, error);
  }
}
function ajaxXHR(options) {
  const xhr = new XMLHttpRequest();
  xhr.open(options.method, options.url, true);
  if (options.headers) {
    for (const [key, value] of Object.entries(options.headers)) {
      xhr.setRequestHeader(key, value);
    }
  }
  if (options.responseType) {
    xhr.responseType = options.responseType;
  }
  if (options.timeout) {
    xhr.timeout = options.timeout;
  }
  if (options.onProgress) {
    xhr.onprogress = (event) => {
      options.onProgress(event.loaded, event.total);
    };
  }
  xhr.onload = function() {
    if (xhr.status >= 200 && xhr.status < 300) {
      if (options.success) {
        const response = options.responseType === "json" ? xhr.response : xhr.responseText;
        options.success(response);
      }
    } else {
      handleError(
        options,
        `Request failed with status ${xhr.status}: ${xhr.statusText}`
      );
    }
  };
  xhr.onerror = function() {
    handleError(options, "Request failed due to network error.");
  };
  xhr.ontimeout = function() {
    handleError(options, `Request timed out after ${xhr.timeout}ms`);
  };
  retryRequest(xhr, options);
  const requestData = formatDataForXHR(options.data, options.headers);
  xhr.send(requestData);
}
async function handleFetchResponse(response, responseType) {
  if (!response.ok) {
    throw new Error(`HTTP error: ${response.status}`);
  }
  switch (responseType) {
    case "json":
      return await response.json();
    case "blob":
      return await response.blob();
    case "arraybuffer":
      return await response.arrayBuffer();
    default:
      return await response.text();
  }
}
function formatDataForFetch(data, headers) {
  if (data && typeof data === "object" && !(data instanceof FormData)) {
    if (headers && headers["Content-Type"] === "application/json") {
      return JSON.stringify(data);
    }
  }
  return data;
}
function handleError(options, error) {
  if (options.error) {
    options.error(error);
  } else {
    console.error(error);
  }
}
function retryRequest(xhr, options, attempt = 1) {
  xhr.onloadend = () => {
    if (xhr.status >= 400 && attempt <= (options.retries || 1)) {
      setTimeout(() => {
        console.warn(
          `Retrying request... (${attempt}/${options.retries})`
        );
        ajaxXHR({ ...options, retries: options.retries - 1 });
      }, options.retryDelay || 1e3);
    }
  };
}
function formatDataForXHR(data, headers) {
  if (data && typeof data === "object" && !(data instanceof FormData)) {
    if (headers && headers["Content-Type"] === "application/json") {
      return JSON.stringify(data);
    }
  }
  return data;
}
function ajax(options) {
  if (options.useFetch) {
    return ajaxFetch(options);
  } else {
    return ajaxXHR(options);
  }
}
function get(url, data = {}, options = {}) {
  const queryString = Object.entries(data).map(
    ([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`
  ).join("&");
  const fullUrl = queryString ? `${url}?${queryString}` : url;
  return ajax({
    method: "GET",
    url: fullUrl,
    ...options
  });
}
function post(url, data, options = {}) {
  return ajax({
    method: "POST",
    url,
    data,
    headers: { "Content-Type": "application/json" },
    ...options
  });
}
function put(url, data, options = {}) {
  return ajax({
    method: "PUT",
    url,
    data,
    headers: { "Content-Type": "application/json" },
    ...options
  });
}
function patch(url, data, options = {}) {
  return ajax({
    method: "PATCH",
    url,
    data,
    headers: { "Content-Type": "application/json" },
    ...options
  });
}
function deleteRequest(url, data = {}, options = {}) {
  const queryString = Object.entries(data).map(
    ([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`
  ).join("&");
  const fullUrl = queryString ? `${url}?${queryString}` : url;
  return ajax({
    method: "DELETE",
    url: fullUrl,
    ...options
  });
}
var Request = {
  ajax,
  get,
  patch,
  post,
  put,
  deleteRequest
};
var request_default = Request;

// src/utils/parse-css.ts
function toCamelCase(property) {
  return property.replace(/-([a-z])/g, (_, letter) => letter.toUpperCase());
}
function parseCss(cssText) {
  const styleObject = {};
  const inlineCss = {};
  const camelCaseObject = {};
  const hyphenatedObject = {};
  const ruleRegex = /([^{]+)\s*{\s*([^}]+)\s*}/g;
  let match;
  while ((match = ruleRegex.exec(cssText)) !== null) {
    const selector = match[1].trim();
    const rules = match[2].trim().split(";").map((rule) => rule.trim()).filter(Boolean);
    const properties = {};
    const camelCaseProperties = {};
    const hyphenatedProperties = {};
    let inlineStyle = "";
    for (const rule of rules) {
      const [property, value] = rule.split(":").map((part) => part.trim());
      if (property && value) {
        properties[property] = value;
        camelCaseProperties[toCamelCase(property)] = value;
        hyphenatedProperties[property] = value;
        inlineStyle += `${property}: ${value}; `;
      }
    }
    inlineCss[selector] = inlineStyle.trim();
    styleObject[selector] = properties;
    camelCaseObject[selector] = camelCaseProperties;
    hyphenatedObject[selector] = hyphenatedProperties;
  }
  return {
    cssText,
    styleObject,
    inlineCss,
    camelCaseObject,
    hyphenatedObject
  };
}

// src/core/css.ts
function addStyles(elements, styles) {
  if (Array.isArray(elements)) {
    elements.forEach((element) => style2(element, styles));
  } else {
    style2(elements, styles);
  }
  function style2(element, styles2) {
    for (const property in styles2) {
      if (styles2.hasOwnProperty(property)) {
        element.style[property] = styles2[property];
      }
    }
  }
}
function removeStylesByProps(element, ...properties) {
  for (const property of properties) {
    element.style[property] = "";
  }
}
function resetStyles(element, styles) {
  for (const property in styles) {
    if (styles.hasOwnProperty(property)) {
      element.style[property] = "";
    }
  }
}
function getAllStyles(element) {
  const styles = {};
  for (let i = 0; i < element.style.length; i++) {
    const property = element.style[i];
    styles[property] = element.style[property];
  }
  return styles;
}
async function loadAsync(url) {
  return new Promise((resolve, reject) => {
    request_default.get(
      url,
      {},
      {
        useFetch: true,
        success: (cssText) => {
          resolve(parseCss(cssText));
        },
        error: (error) => {
          reject(error);
        }
      }
    );
  });
}
function load(url) {
  const xhr = new XMLHttpRequest();
  xhr.open("GET", url, false);
  xhr.send(null);
  if (xhr.status !== 200) {
    throw new Error(`Failed to load CSS: ${xhr.status}`);
  }
  const cssText = xhr.responseText;
  return parseCss(cssText);
}

// src/modules/css.ts
var CSS = {
  addStyles,
  removeStylesByProps,
  resetStyles,
  load,
  loadAsync,
  getAllStyles
};
var css_default = CSS;

// node_modules/@butility/dom/html.js
function create(name, options = {}, callback) {
  const element = document.createElement(name);
  if (options.class && Array.isArray(options.class)) {
    options.class.forEach((className) => {
      if (className) {
        element.classList.add(className);
      }
    });
  }
  if (options.attr) {
    for (const key in options.attr) {
      if (Object.hasOwnProperty.call(options.attr, key)) {
        element.setAttribute(key, options.attr[key]);
      }
    }
  }
  if (options.innerText) element.innerText = options.innerText;
  if (options.innerHTML) element.innerHTML = options.innerHTML;
  if (options.children && Array.isArray(options.children)) {
    options.children.forEach((child) => {
      if (child instanceof HTMLElement) {
        element.appendChild(child);
      }
    });
  }
  if (options.draggable) element.draggable = true;
  if (options.style) element.style.cssText = options.style;
  if (options.trackMutation) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        console.log("Mutation observed:", mutation);
      });
    });
    observer.observe(element, { attributes: true, childList: true, subtree: true });
  }
  if (callback && typeof callback === "function") callback(element);
  return element;
}
function setAttribute(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(attribute)) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log) console.log(`Skipping attribute: ${finalAttributeName}`);
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(`Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`);
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log) console.log(`Set data attribute: data-${dataKey} = ${transformedValue}`);
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log) console.log(`Set attribute: ${finalAttributeName} = ${transformedValue}`);
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}
function setAttributeOrChildren(element, ...attributesOrChildren) {
  attributesOrChildren.forEach((item) => {
    if (typeof item === "object" && !(item instanceof HTMLElement)) {
      setAttribute(element, item);
    } else if (item instanceof HTMLElement || typeof item === "string") {
      element.append(item);
    }
  });
}
function link(...attributesOrChildren) {
  const element = create("link");
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}
function style(...attributesOrChildren) {
  const element = create("style");
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}
function head(...attributesOrChildren) {
  setAttributeOrChildren(document.head, ...attributesOrChildren);
  return document.head;
}

// src/core/font.ts
function loadWebFont({
  family,
  weight = "400",
  style: style2 = "normal",
  subsets = ["latin"],
  elements = ["body"],
  fallbackFonts = ["sans-serif"],
  display = "swap",
  lazyLoad = false,
  preload = false
}) {
  const formattedFamily = family.replace(/\s+/g, "+");
  const fontUrl = `https://fonts.googleapis.com/css2?family=${formattedFamily}:wght@${weight}&subset=${subsets.join(",")}&display=${display}`;
  if (preload) {
    head(link({ rel: preload, href: fontUrl, as: "style" }));
  }
  const link2 = link({ rel: "stylesheet", href: fontUrl });
  const injectCSS = () => {
    const fontStack = [family, ...fallbackFonts].join(", ");
    const cssRules = elements.map(
      (selector) => `${selector} { font-family: "${fontStack}"; font-style: ${style2}; font-weight: ${weight}; }`
    ).join(" ");
    head(style({ type: "text/css" }, document.createTextNode(cssRules)));
  };
  link2.onload = () => {
    injectCSS();
  };
  link2.onerror = () => {
    console.error(`Failed to load font: ${family}`);
  };
  if (!lazyLoad) {
    head(link2);
  }
  if (lazyLoad) {
    const observer = new IntersectionObserver(
      (entries, obs) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            head(link2);
            obs.disconnect();
          }
        });
      },
      { threshold: 0.1 }
      // Load the font when 10% of the element is visible
    );
    const firstElement = document.querySelector(elements[0]);
    if (firstElement) {
      observer.observe(firstElement);
    } else {
      console.warn(`No elements found for selector: ${elements[0]}`);
    }
  }
  if (document.fonts && document.fonts.check(`1em ${family}`)) {
    injectCSS();
  }
}
function loadWebFontAsync({
  family,
  weight = "400",
  style: style2 = "normal",
  subsets = ["latin"],
  elements = ["body"],
  fallbackFonts = ["sans-serif"],
  display = "swap",
  lazyLoad = false,
  preload = false,
  timeout = 5e3,
  // Default timeout of 5 seconds
  onLoadSuccess = () => {
  },
  onLoadError = (error) => {
    console.error(error);
  },
  observerOptions = { threshold: 0.1 }
  // Default IntersectionObserver threshold
}) {
  return new Promise((resolve, reject) => {
    const formattedFamily = family.replace(/\s+/g, "+");
    const fontUrl = `https://fonts.googleapis.com/css2?family=${formattedFamily}:wght@${weight}&subset=${subsets.join(",")}&display=${display}`;
    if (preload) {
      head(link({ rel: "preload", href: fontUrl, as: "style" }));
    }
    const link2 = link({ rel: "stylesheet", href: fontUrl });
    const injectCSS = () => {
      const fontStack = [family, ...fallbackFonts].join(", ");
      const cssRules = elements.map(
        (selector) => `${selector} { font-family: "${fontStack}"; font-style: ${style2}; font-weight: ${weight}; }`
      ).join(" ");
      head(
        style({ type: "text/css" }, document.createTextNode(cssRules))
      );
    };
    link2.onload = () => {
      injectCSS();
      onLoadSuccess();
      resolve();
    };
    link2.onerror = (event) => {
      const error = new Error(`Failed to load font: ${family}`);
      onLoadError(error);
      reject(error);
    };
    if (!lazyLoad) {
      head(link2);
    }
    if (lazyLoad) {
      const observer = new IntersectionObserver((entries, obs) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            head(link2);
            obs.disconnect();
          }
        });
      }, observerOptions);
      const firstElement = document.querySelector(elements[0]);
      if (firstElement) {
        observer.observe(firstElement);
      } else {
        console.warn(`No elements found for selector: ${elements[0]}`);
      }
    }
    if (document.fonts && document.fonts.check(`1em ${family}`)) {
      injectCSS();
      onLoadSuccess();
      resolve();
      return;
    }
    const timeoutId = setTimeout(() => {
      const error = new Error(
        `Font loading timed out after ${timeout}ms: ${family}`
      );
      onLoadError(error);
      reject(error);
    }, timeout);
    link2.onload = () => {
      clearTimeout(timeoutId);
      injectCSS();
      onLoadSuccess();
      resolve();
    };
    link2.onerror = (event) => {
      clearTimeout(timeoutId);
      const error = new Error(`Failed to load font: ${family}`);
      onLoadError(error);
      reject(error);
    };
    if (!lazyLoad) {
      head(link2);
    }
  });
}

// src/modules/font.ts
var Font = {
  load: loadWebFont,
  loadAsync: loadWebFontAsync
};
var font_default = Font;

// src/core/state.ts
function setStateBasedStyle(element, config) {
  for (const state in config) {
    const value = config[state];
    if (typeof value === "object" && !Array.isArray(value)) {
      const styles = value;
      switch (state) {
        case "hover":
          element.addEventListener(
            "mouseover",
            () => addStyles(element, styles)
          );
          element.addEventListener(
            "mouseout",
            () => resetStyles(element, styles)
          );
          break;
        case "active":
          element.addEventListener(
            "mousedown",
            () => addStyles(element, styles)
          );
          element.addEventListener(
            "mouseup",
            () => resetStyles(element, styles)
          );
          break;
        case "focus":
          element.addEventListener(
            "focus",
            () => addStyles(element, styles)
          );
          element.addEventListener(
            "blur",
            () => resetStyles(element, styles)
          );
          break;
        case "click":
          element.addEventListener(
            "click",
            () => addStyles(element, styles)
          );
          break;
        default:
          console.warn(`Unsupported state: ${state}`);
          break;
      }
    } else if (typeof value === "object" && "eventName" in value) {
      const { eventName, styles } = value;
      element.addEventListener(
        eventName,
        () => addStyles(element, styles)
      );
      element.addEventListener(
        "mouseleave",
        () => resetStyles(element, styles)
      );
    }
  }
}

// src/modules/state.ts
var state_default = setStateBasedStyle;

// src/core/theme.ts
var ThemeManager = class {
  constructor(initialThemes) {
    this.themes = {};
    this.currentTheme = null;
    if (initialThemes) {
      this.themes = initialThemes;
    }
    this.loadThemeFromStorage();
    this.detectSystemTheme();
    this.watchSystemTheme();
  }
  // Create a new theme
  createTheme(name, theme) {
    this.themes[name] = theme;
  }
  // Set a theme by name
  setTheme(name) {
    const theme = this.themes[name];
    if (!theme) {
      console.warn(`Theme ${name} does not exist.`);
      return;
    }
    Object.entries(theme).forEach(([key, value]) => {
      document.documentElement.style.setProperty(`--${key}`, value);
    });
    this.currentTheme = name;
    localStorage.setItem("theme", name);
  }
  getCurrentTheme() {
    return this.currentTheme;
  }
  // Load theme from local storage
  loadThemeFromStorage() {
    const storedTheme = localStorage.getItem("theme");
    if (storedTheme && this.themes[storedTheme]) {
      this.setTheme(storedTheme);
    }
  }
  // Detect system theme (light/dark) and set it
  detectSystemTheme() {
    const prefersDarkScheme = window.matchMedia(
      "(prefers-color-scheme: dark)"
    ).matches;
    this.setTheme(prefersDarkScheme ? "dark" : "light");
  }
  // Watch for system theme changes and update theme
  watchSystemTheme() {
    window.matchMedia("(prefers-color-scheme: dark)").addEventListener("change", (event) => {
      this.setTheme(event.matches ? "dark" : "light");
    });
  }
};

// src/modules/theme.ts
var theme_default = ThemeManager;

// src/index.ts
var Style = {
  calculateLuminance,
  colorBrightness,
  colorContrast,
  darkenColor,
  generateColorGradient,
  generateRandomColor,
  hexToRgb,
  hexToRgba,
  hslToRgb,
  hueToRgb,
  invertColor,
  lightenColor,
  mixColors,
  rgbToHex,
  rgbToHsl,
  rgbaToHex,
  loadWebFont,
  loadWebFontAsync,
  addStyles,
  removeStylesByProps,
  resetStyles,
  load,
  loadAsync,
  getAllStyles,
  ThemeManager: theme_default,
  setStateBasedStyle: state_default
};
export {
  css_default as CSS,
  color_default as Color,
  font_default as Font,
  addStyles,
  calculateLuminance,
  colorBrightness,
  colorContrast,
  darkenColor,
  Style as default,
  generateColorGradient,
  generateRandomColor,
  getAllStyles,
  hexToRgb,
  hexToRgba,
  hslToRgb,
  hueToRgb,
  invertColor,
  lightenColor,
  load,
  loadAsync,
  loadWebFont,
  loadWebFontAsync,
  mixColors,
  removeStylesByProps,
  resetStyles,
  rgbToHex,
  rgbToHsl,
  rgbaToHex
};
