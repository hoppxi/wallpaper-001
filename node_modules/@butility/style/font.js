// node_modules/@butility/dom/html.js
function create(name, options = {}, callback) {
  const element = document.createElement(name);
  if (options.class && Array.isArray(options.class)) {
    options.class.forEach((className) => {
      if (className) {
        element.classList.add(className);
      }
    });
  }
  if (options.attr) {
    for (const key in options.attr) {
      if (Object.hasOwnProperty.call(options.attr, key)) {
        element.setAttribute(key, options.attr[key]);
      }
    }
  }
  if (options.innerText) element.innerText = options.innerText;
  if (options.innerHTML) element.innerHTML = options.innerHTML;
  if (options.children && Array.isArray(options.children)) {
    options.children.forEach((child) => {
      if (child instanceof HTMLElement) {
        element.appendChild(child);
      }
    });
  }
  if (options.draggable) element.draggable = true;
  if (options.style) element.style.cssText = options.style;
  if (options.trackMutation) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        console.log("Mutation observed:", mutation);
      });
    });
    observer.observe(element, { attributes: true, childList: true, subtree: true });
  }
  if (callback && typeof callback === "function") callback(element);
  return element;
}
function setAttribute(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(attribute)) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log) console.log(`Skipping attribute: ${finalAttributeName}`);
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(`Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`);
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log) console.log(`Set data attribute: data-${dataKey} = ${transformedValue}`);
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log) console.log(`Set attribute: ${finalAttributeName} = ${transformedValue}`);
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}
function setAttributeOrChildren(element, ...attributesOrChildren) {
  attributesOrChildren.forEach((item) => {
    if (typeof item === "object" && !(item instanceof HTMLElement)) {
      setAttribute(element, item);
    } else if (item instanceof HTMLElement || typeof item === "string") {
      element.append(item);
    }
  });
}
function link(...attributesOrChildren) {
  const element = create("link");
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}
function style(...attributesOrChildren) {
  const element = create("style");
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}
function head(...attributesOrChildren) {
  setAttributeOrChildren(document.head, ...attributesOrChildren);
  return document.head;
}

// src/core/font.ts
function loadWebFont({
  family,
  weight = "400",
  style: style2 = "normal",
  subsets = ["latin"],
  elements = ["body"],
  fallbackFonts = ["sans-serif"],
  display = "swap",
  lazyLoad = false,
  preload = false
}) {
  const formattedFamily = family.replace(/\s+/g, "+");
  const fontUrl = `https://fonts.googleapis.com/css2?family=${formattedFamily}:wght@${weight}&subset=${subsets.join(",")}&display=${display}`;
  if (preload) {
    head(link({ rel: preload, href: fontUrl, as: "style" }));
  }
  const link2 = link({ rel: "stylesheet", href: fontUrl });
  const injectCSS = () => {
    const fontStack = [family, ...fallbackFonts].join(", ");
    const cssRules = elements.map(
      (selector) => `${selector} { font-family: "${fontStack}"; font-style: ${style2}; font-weight: ${weight}; }`
    ).join(" ");
    head(style({ type: "text/css" }, document.createTextNode(cssRules)));
  };
  link2.onload = () => {
    injectCSS();
  };
  link2.onerror = () => {
    console.error(`Failed to load font: ${family}`);
  };
  if (!lazyLoad) {
    head(link2);
  }
  if (lazyLoad) {
    const observer = new IntersectionObserver(
      (entries, obs) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            head(link2);
            obs.disconnect();
          }
        });
      },
      { threshold: 0.1 }
      // Load the font when 10% of the element is visible
    );
    const firstElement = document.querySelector(elements[0]);
    if (firstElement) {
      observer.observe(firstElement);
    } else {
      console.warn(`No elements found for selector: ${elements[0]}`);
    }
  }
  if (document.fonts && document.fonts.check(`1em ${family}`)) {
    injectCSS();
  }
}
function loadWebFontAsync({
  family,
  weight = "400",
  style: style2 = "normal",
  subsets = ["latin"],
  elements = ["body"],
  fallbackFonts = ["sans-serif"],
  display = "swap",
  lazyLoad = false,
  preload = false,
  timeout = 5e3,
  // Default timeout of 5 seconds
  onLoadSuccess = () => {
  },
  onLoadError = (error) => {
    console.error(error);
  },
  observerOptions = { threshold: 0.1 }
  // Default IntersectionObserver threshold
}) {
  return new Promise((resolve, reject) => {
    const formattedFamily = family.replace(/\s+/g, "+");
    const fontUrl = `https://fonts.googleapis.com/css2?family=${formattedFamily}:wght@${weight}&subset=${subsets.join(",")}&display=${display}`;
    if (preload) {
      head(link({ rel: "preload", href: fontUrl, as: "style" }));
    }
    const link2 = link({ rel: "stylesheet", href: fontUrl });
    const injectCSS = () => {
      const fontStack = [family, ...fallbackFonts].join(", ");
      const cssRules = elements.map(
        (selector) => `${selector} { font-family: "${fontStack}"; font-style: ${style2}; font-weight: ${weight}; }`
      ).join(" ");
      head(
        style({ type: "text/css" }, document.createTextNode(cssRules))
      );
    };
    link2.onload = () => {
      injectCSS();
      onLoadSuccess();
      resolve();
    };
    link2.onerror = (event) => {
      const error = new Error(`Failed to load font: ${family}`);
      onLoadError(error);
      reject(error);
    };
    if (!lazyLoad) {
      head(link2);
    }
    if (lazyLoad) {
      const observer = new IntersectionObserver((entries, obs) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting) {
            head(link2);
            obs.disconnect();
          }
        });
      }, observerOptions);
      const firstElement = document.querySelector(elements[0]);
      if (firstElement) {
        observer.observe(firstElement);
      } else {
        console.warn(`No elements found for selector: ${elements[0]}`);
      }
    }
    if (document.fonts && document.fonts.check(`1em ${family}`)) {
      injectCSS();
      onLoadSuccess();
      resolve();
      return;
    }
    const timeoutId = setTimeout(() => {
      const error = new Error(
        `Font loading timed out after ${timeout}ms: ${family}`
      );
      onLoadError(error);
      reject(error);
    }, timeout);
    link2.onload = () => {
      clearTimeout(timeoutId);
      injectCSS();
      onLoadSuccess();
      resolve();
    };
    link2.onerror = (event) => {
      clearTimeout(timeoutId);
      const error = new Error(`Failed to load font: ${family}`);
      onLoadError(error);
      reject(error);
    };
    if (!lazyLoad) {
      head(link2);
    }
  });
}

// src/modules/font.ts
var Font = {
  load: loadWebFont,
  loadAsync: loadWebFontAsync
};
var font_default = Font;
export {
  font_default as default,
  loadWebFont,
  loadWebFontAsync
};
