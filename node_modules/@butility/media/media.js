// node_modules/@butility/dom/html.js
function create(name, options = {}, callback) {
  const element = document.createElement(name);
  if (options.class && Array.isArray(options.class)) {
    options.class.forEach((className) => {
      if (className) {
        element.classList.add(className);
      }
    });
  }
  if (options.attr) {
    for (const key in options.attr) {
      if (Object.hasOwnProperty.call(options.attr, key)) {
        element.setAttribute(key, options.attr[key]);
      }
    }
  }
  if (options.innerText) element.innerText = options.innerText;
  if (options.innerHTML) element.innerHTML = options.innerHTML;
  if (options.children && Array.isArray(options.children)) {
    options.children.forEach((child) => {
      if (child instanceof HTMLElement) {
        element.appendChild(child);
      }
    });
  }
  if (options.draggable) element.draggable = true;
  if (options.style) element.style.cssText = options.style;
  if (options.trackMutation) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        console.log("Mutation observed:", mutation);
      });
    });
    observer.observe(element, { attributes: true, childList: true, subtree: true });
  }
  if (callback && typeof callback === "function") callback(element);
  return element;
}
function setAttribute(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(attribute)) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log) console.log(`Skipping attribute: ${finalAttributeName}`);
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(`Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`);
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log) console.log(`Set data attribute: data-${dataKey} = ${transformedValue}`);
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log) console.log(`Set attribute: ${finalAttributeName} = ${transformedValue}`);
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}
function setAttributeOrChildren(element, ...attributesOrChildren) {
  attributesOrChildren.forEach((item) => {
    if (typeof item === "object" && !(item instanceof HTMLElement)) {
      setAttribute(element, item);
    } else if (item instanceof HTMLElement || typeof item === "string") {
      element.append(item);
    }
  });
}
function a(...attributesOrChildren) {
  const element = create("a");
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}
function source(...attributesOrChildren) {
  const element = create("source");
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}
function canvas(...attributesOrChildren) {
  const element = create("canvas");
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}
function body(...attributesOrChildren) {
  setAttributeOrChildren(document.body, ...attributesOrChildren);
  return document.body;
}

// src/core/blob.ts
function convertBase64ToBlob(base64, contentType, onProgress) {
  try {
    const byteCharacters = atob(base64);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
      if (onProgress) onProgress(i / byteCharacters.length);
    }
    const byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], { type: contentType });
  } catch (error) {
    throw new Error(`Failed to convert base64 to Blob: ${error.message}`);
  }
}
async function convertBlobToBase64(blob, onProgress) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onprogress = (event) => {
      if (event.lengthComputable && onProgress) {
        onProgress(event.loaded / event.total);
      }
    };
    reader.onloadend = () => {
      if (reader.result) {
        const base64String = reader.result.split(",")[1];
        resolve(base64String);
      } else {
        reject(new Error("Reader result is empty"));
      }
    };
    reader.onerror = () => reject(new Error("Failed to convert Blob to base64"));
    reader.readAsDataURL(blob);
  });
}
function downloadBlob(blob, filename, fallbackContentType = "application/octet-stream") {
  const contentType = blob.type || fallbackContentType;
  const url = URL.createObjectURL(new Blob([blob], { type: contentType }));
  const link = a({ href: url, download: filename });
  body(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
function textToBlob(text, encoding = "utf-8") {
  const encoder = new TextEncoder();
  const uint8Array = encoder.encode(text);
  return new Blob([uint8Array], { type: `text/plain;charset=${encoding}` });
}
function mergeBlobs(blobs, contentType = "application/octet-stream", bufferSize = 1024) {
  const blobBuffers = blobs.map((blob) => blob.slice(0, bufferSize));
  return new Blob(blobBuffers, { type: contentType });
}
async function encryptBlob(blob, key) {
  const arrayBuffer = await blob.arrayBuffer();
  const iv = window.crypto.getRandomValues(new Uint8Array(12));
  const encryptedData = await window.crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    arrayBuffer
  );
  return new Blob([iv, encryptedData], { type: blob.type });
}
async function decryptBlob(encryptedBlob, key) {
  const arrayBuffer = await encryptedBlob.arrayBuffer();
  const iv = arrayBuffer.slice(0, 12);
  const encryptedData = arrayBuffer.slice(12);
  const decryptedData = await window.crypto.subtle.decrypt(
    { name: "AES-GCM", iv: new Uint8Array(iv) },
    key,
    encryptedData
  );
  return new Blob([decryptedData], { type: encryptedBlob.type });
}
function chunkBlob(blob, chunkSize) {
  const chunks = [];
  let offset = 0;
  while (offset < blob.size) {
    const chunk = blob.slice(offset, offset + chunkSize);
    chunks.push(chunk);
    offset += chunkSize;
  }
  return chunks;
}
async function readBlobAsText(blob, encoding = "utf-8") {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(new Error("Failed to read Blob as text"));
    reader.readAsText(blob, encoding);
  });
}
function verifyBlob(blob, options = {}) {
  if (options.maxSize && blob.size > options.maxSize) {
    return false;
  }
  if (options.allowedTypes && !options.allowedTypes.includes(blob.type)) {
    return false;
  }
  return true;
}
async function blobToHex(blob) {
  const arrayBuffer = await blob.arrayBuffer();
  const byteArray = new Uint8Array(arrayBuffer);
  const hexString = Array.from(byteArray).map((byte) => byte.toString(16).padStart(2, "0")).join("");
  return hexString;
}

// src/modules/blob.ts
var Blob2 = {
  blobToHex,
  chunkBlob,
  convertBase64ToBlob,
  convertBlobToBase64,
  decryptBlob,
  downloadBlob,
  encryptBlob,
  mergeBlobs,
  readBlobAsText,
  textToBlob,
  verifyBlob
};
var blob_default = Blob2;

// node_modules/@butility/dom/attribute.js
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var attribute_exports = {};
__export(attribute_exports, {
  attributesToQueryString: () => attributesToQueryString,
  compareAttributes: () => compareAttributes,
  copyAttributes: () => copyAttributes,
  findElementByAttribute: () => findElementByAttribute,
  getAllAttributes: () => getAllAttributes,
  getAttribute: () => getAttribute,
  getAttributesByPrefix: () => getAttributesByPrefix,
  hasAnyAttributes: () => hasAnyAttributes,
  hasAttribute: () => hasAttribute,
  removeAllAttributes: () => removeAllAttributes,
  removeAttribute: () => removeAttribute,
  removeAttributesByName: () => removeAttributesByName,
  removeAttributesByPrefix: () => removeAttributesByPrefix,
  setAttribute: () => setAttribute2,
  setAttributesFromQueryString: () => setAttributesFromQueryString,
  toggleAttribute: () => toggleAttribute,
  toggleAttributes: () => toggleAttributes
});
function setAttribute2(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(attribute)) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log) console.log(`Skipping attribute: ${finalAttributeName}`);
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(`Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`);
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log) console.log(`Set data attribute: data-${dataKey} = ${transformedValue}`);
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log) console.log(`Set attribute: ${finalAttributeName} = ${transformedValue}`);
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}
function removeAttribute(element, attributeName) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  if (/^data-/.test(attributeName)) {
    delete element.dataset[attributeName.slice(5)];
  } else if (element.hasAttribute(attributeName)) {
    element.removeAttribute(attributeName);
  } else {
    console.warn(`Attribute "${attributeName}" does not exist on`, element);
  }
}
function getAttribute(element, attributeName, options) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const result = {};
  let value;
  if (options?.dataPrefix && /^data-/.test(attributeName)) {
    value = element.dataset[attributeName.slice(5)] || null;
  } else {
    value = element.getAttribute(attributeName);
  }
  if (options?.transform) {
    value = options.transform(value);
  }
  result[attributeName] = value !== null ? value : options?.defaultValue || null;
  return result;
}
function getAllAttributes(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const attributes = {};
  Array.from(element.attributes).forEach((attr) => {
    attributes[attr.name] = attr.value;
  });
  Object.keys(element.dataset).forEach((dataKey) => {
    const dataValue = element.dataset[dataKey];
    if (dataValue !== void 0) {
      attributes[`data-${dataKey}`] = dataValue;
    }
  });
  return attributes;
}
function hasAttribute(element, attributeName) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  return /^data-/.test(attributeName) ? attributeName.slice(5) in element.dataset : element.hasAttribute(attributeName);
}
function toggleAttribute(element, attributeName, attributeValue) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  if (hasAttribute(element, attributeName)) {
    removeAttribute(element, attributeName);
  } else {
    setAttribute2(element, {
      [attributeName]: attributeValue
    });
  }
}
function removeAllAttributes(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  Array.from(element.attributes).forEach((attr) => {
    element.removeAttribute(attr.name);
  });
  Object.keys(element.dataset).forEach((dataKey) => {
    delete element.dataset[dataKey];
  });
}
function attributesToQueryString(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const attributes = Array.from(element.attributes);
  return attributes.map((attr) => `${encodeURIComponent(attr.name)}=${encodeURIComponent(attr.value)}`).join("&");
}
function copyAttributes(element, target) {
  if (!element || !(element instanceof HTMLElement) || !target || !(target instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  Array.from(element.attributes).forEach((attr) => {
    setAttribute2(target, { [attr.name]: attr.value });
  });
}
function findElementByAttribute(Element, attributeName) {
  return Array.from(Element.querySelectorAll(`[${attributeName}]`));
}
function toggleAttributes(element, attributes) {
  Object.keys(attributes).forEach((attr) => {
    if (attributes[attr]) {
      element.setAttribute(attr, "");
    } else {
      element.removeAttribute(attr);
    }
  });
}
function hasAnyAttributes(element) {
  return element.attributes.length > 0;
}
function removeAttributesByName(element, ...attributeNames) {
  attributeNames.forEach((attr) => {
    element.removeAttribute(attr);
  });
}
function getAttributesByPrefix(element, prefix) {
  const result = {};
  Array.from(element.attributes).forEach((attr) => {
    if (attr.name.startsWith(prefix)) {
      result[attr.name] = attr.value;
    }
  });
  return result;
}
function setAttributesFromQueryString(element, queryString, options = {}) {
  const {
    onError = (error) => console.error(error)
  } = options;
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof queryString !== "string" || !queryString.trim()) {
      throw new Error("Invalid queryString provided. It must be a non-empty string.");
    }
    const params = new URLSearchParams(queryString);
    try {
      setAttribute2(element, params, options);
    } catch (attrError) {
      onError(attrError);
    }
  } catch (error) {
    onError(error);
  }
}
function compareAttributes(el1, el2, options = {}) {
  const diff = {};
  try {
    if (!(el1 instanceof HTMLElement) || !(el2 instanceof HTMLElement)) {
      throw new TypeError("Both el1 and el2 must be valid HTMLElements.");
    }
    const el1Attributes = el1.attributes;
    const el2Attributes = el2.attributes;
    const {
      onTrue = () => {
      },
      // Default no-op callback if not provided
      onFalse = () => {
      },
      // Default no-op callback if not provided
      ignoreAttributes = [],
      customCompare
    } = options;
    const shouldIgnore = (attrName) => ignoreAttributes.includes(attrName);
    Array.from(el1Attributes).forEach((attr) => {
      const el2Value = el2.getAttribute(attr.name);
      if (shouldIgnore(attr.name)) return;
      const isEqual = customCompare ? customCompare(attr.value, el2Value) : attr.value === el2Value;
      if (!isEqual) {
        diff[attr.name] = { el1Value: attr.value, el2Value };
        onFalse(attr.name, attr.value, el2Value);
      } else {
        onTrue(attr.name, attr.value, el2Value);
      }
    });
    Array.from(el2Attributes).forEach((attr) => {
      if (!el1.hasAttribute(attr.name) && !shouldIgnore(attr.name)) {
        diff[attr.name] = { el1Value: null, el2Value: attr.value };
        onFalse(attr.name, null, attr.value);
      }
    });
  } catch (error) {
    console.error(`Error comparing attributes: ${error.message}`);
  }
  return diff;
}
function removeAttributesByPrefix(element, prefixes, options) {
  const { onRemove, protectedAttr } = options;
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    const prefixList = Array.isArray(prefixes) ? prefixes : [prefixes];
    if (prefixList.length === 0 || prefixList.some((prefix) => typeof prefix !== "string" || !prefix.trim())) {
      throw new Error("Invalid prefixes provided. Prefixes must be non-empty strings.");
    }
    Array.from(element.attributes).forEach((attr) => {
      const attrName = attr.name;
      const shouldRemove = prefixList.some((prefix) => attrName.startsWith(prefix));
      if (shouldRemove) {
        if (typeof onRemove === "function") {
          onRemove(attrName);
        }
        const isRemovable = (attrName2) => {
          if (protectedAttr) {
            return !protectedAttr.includes(attrName2);
          }
        };
        if (isRemovable(attrName) === true) {
          element.removeAttribute(attrName);
        }
      }
    });
  } catch (error) {
    console.error(`Error while removing attributes by prefix: ${error.message}`);
  }
}
var Attribute = { ...attribute_exports };

// src/core/camera.ts
function openCamera(options = {
  targetElementId: "camera"
}) {
  const { targetElementId } = options;
  return new Promise((resolve, reject) => {
    const videoElement = document.getElementById(
      targetElementId
    );
    if (!videoElement) {
      reject(new Error(`Element with ID ${targetElementId} not found.`));
      return;
    }
    navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then((stream) => {
      videoElement.srcObject = stream;
      resolve(stream);
    }).catch((error) => {
      reject(error);
    });
  });
}
function capturePhoto(options = {
  targetElementId: "camera",
  fileType: "png"
}) {
  const { targetElementId, fileType } = options;
  return new Promise((resolve, reject) => {
    const videoElement = document.getElementById(
      targetElementId
    );
    if (!videoElement) {
      reject(new Error(`Element with ID ${targetElementId} not found.`));
      return;
    }
    navigator.mediaDevices.getUserMedia({ video: true }).then((mediaStream) => {
      setAttribute2(videoElement, { srcObject: mediaStream });
      const canvas2 = canvas();
      const context = canvas2.getContext("2d");
      videoElement.addEventListener("loadedmetadata", () => {
        setAttribute2(canvas2, {
          width: videoElement.videoWidth,
          height: videoElement.videoHeight
        });
        if (context) {
          context.drawImage(
            videoElement,
            0,
            0,
            canvas2.width,
            canvas2.height
          );
          canvas2.toBlob((blob) => {
            resolve(blob);
            mediaStream.getTracks().forEach((track) => track.stop());
          }, `image/${fileType}`);
        } else {
          reject(new Error("Failed to get canvas 2D context."));
        }
      });
      videoElement.onerror = () => {
        reject(new Error("Error capturing photo."));
      };
    }).catch((error) => {
      reject(new Error("Unable to access camera: " + error.message));
    });
  });
}
function recordVideo(options = {
  targetElementId: "camera",
  fileType: "webm",
  start: (startRecording) => startRecording(),
  stop: (mediaRecorder) => mediaRecorder.stop(),
  removeAudio: false,
  removeVideo: false
}) {
  const {
    targetElementId,
    duration,
    fileType,
    start,
    stop,
    removeAudio,
    removeVideo
  } = options;
  return new Promise((resolve, reject) => {
    const startRecording = () => {
      navigator.mediaDevices.getUserMedia({
        video: !removeVideo,
        audio: !removeAudio
      }).then((stream) => {
        const mediaStream = stream;
        const videoElement = document.getElementById(
          targetElementId
        );
        if (!videoElement) {
          reject(
            new Error(
              `Element with ID ${targetElementId} not found or camera not opened.`
            )
          );
          return;
        }
        setAttribute2(videoElement, { srcObject: mediaStream, muted: true });
        const mediaRecorder = new MediaRecorder(mediaStream, {
          mimeType: `video/${fileType}`
        });
        const chunks = [];
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            chunks.push(event.data);
          }
        };
        mediaRecorder.onstop = () => {
          const videoBlob = new Blob(chunks, {
            type: `video/${fileType}`
          });
          resolve(videoBlob);
          mediaStream.getTracks().forEach((track) => track.stop());
        };
        mediaRecorder.start();
        if (duration) {
          setTimeout(() => {
            mediaRecorder.stop();
          }, duration);
        } else {
          stop(mediaRecorder);
        }
      }).catch((error) => {
        reject(error);
      });
    };
    start(startRecording);
  });
}

// src/modules/camera.ts
var Camera = {
  capturePhoto,
  openCamera,
  recordVideo
};
var camera_default = Camera;

// src/core/image.ts
function resizeImage(file, maxWidth, maxHeight) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const canvas2 = canvas();
      const ctx = canvas2.getContext("2d");
      let width = img.width;
      let height = img.height;
      if (width > maxWidth) {
        height *= maxWidth / width;
        width = maxWidth;
      }
      if (height > maxHeight) {
        width *= maxHeight / height;
        height = maxHeight;
      }
      setAttribute2(canvas2, { width, height });
      if (ctx) ctx.drawImage(img, 0, 0, width, height);
      canvas2.toBlob((blob) => resolve(blob), file.type);
    };
    img.onerror = () => reject(new Error("Failed to load image"));
    setAttribute2(img, { src: URL.createObjectURL(file) });
  });
}
function rotateImage(file, degrees) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const canvas2 = canvas();
      const ctx = canvas2.getContext("2d");
      let width = img.width;
      let height = img.height;
      setAttribute2(canvas2, { width: height, height: width });
      if (ctx) {
        ctx.translate(canvas2.width / 2, canvas2.height / 2);
        ctx.rotate(degrees * (Math.PI / 180));
        ctx.drawImage(
          img,
          -width / 2,
          -height / 2,
          width,
          height
        );
      }
      canvas2.toBlob((blob) => resolve(blob), file.type);
    };
    img.onerror = () => reject(new Error("Failed to load image"));
    setAttribute2(img, { src: URL.createObjectURL(file) });
  });
}
function compressImage(file, quality) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const canvas2 = canvas();
      const ctx = canvas2.getContext("2d");
      let width = img.width;
      let height = img.height;
      setAttribute2(canvas2, { width, height });
      if (ctx) ctx.drawImage(img, 0, 0, width, height);
      canvas2.toBlob((blob) => resolve(blob), file.type, quality);
    };
    img.onerror = () => reject(new Error("Failed to load image"));
    setAttribute2(img, { src: URL.createObjectURL(file) });
  });
}
function cropImage(file, coordinates) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const canvas2 = canvas();
      const ctx = canvas2.getContext("2d");
      setAttribute2(canvas2, {
        width: coordinates.width,
        height: coordinates.height
      });
      if (ctx)
        ctx.drawImage(
          img,
          -coordinates.x,
          -coordinates.y,
          img.width,
          img.height
        );
      canvas2.toBlob((blob) => resolve(blob), file.type);
    };
    img.onerror = () => reject(new Error("Failed to load image"));
    setAttribute2(img, { src: URL.createObjectURL(file) });
  });
}
function flipImage(file, axis) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const canvas2 = canvas();
      const ctx = canvas2.getContext("2d");
      let width = img.width;
      let height = img.height;
      setAttribute2(canvas2, { width, height });
      if (axis === "horizontal" && ctx) {
        ctx.scale(-1, 1);
        ctx.drawImage(img, -width, 0, width, height);
      } else if (axis === "vertical" && ctx) {
        ctx.scale(1, -1);
        ctx.drawImage(img, 0, -height, width, height);
      } else {
        reject(
          new Error('Invalid axis. Use "horizontal" or "vertical".')
        );
        return;
      }
      canvas2.toBlob((blob) => resolve(blob), file.type);
    };
    img.onerror = () => reject(new Error("Failed to load image"));
    setAttribute2(img, { src: URL.createObjectURL(file) });
  });
}
function convertImageToBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      resolve(reader.result.split(",")[1]);
    };
    reader.onerror = () => {
      reject(new Error("Failed to read image as base64."));
    };
    reader.readAsDataURL(file);
  });
}
function preloadImagesWithCallback(imageUrls, callback) {
  const images = [];
  let loadedImages = 0;
  function imageLoaded() {
    loadedImages++;
    if (loadedImages === imageUrls.length) {
      callback(images);
    }
  }
  imageUrls.forEach((url, index) => {
    const img = new Image();
    img.onload = () => {
      images[index] = img;
      imageLoaded();
    };
    img.onerror = () => {
      console.error(`Failed to load image: ${url}`);
      imageLoaded();
    };
    setAttribute2(img, { src: url });
  });
}
function calculateAspectRatio(width, height) {
  return width / height;
}

// src/modules/image.ts
var Image2 = {
  calculateAspectRatio,
  compressImage,
  convertImageToBase64,
  cropImage,
  flipImage,
  preloadImagesWithCallback,
  resizeImage,
  rotateImage
};
var image_default = Image2;

// src/core/full-screen.ts
function detectFullscreenSupport() {
  return document.fullscreenEnabled || document.webkitFullscreenEnabled || document.mozFullScreenEnabled || document.msFullscreenEnabled;
}
function enterFullscreen(element) {
  if (element.requestFullscreen) {
    element.requestFullscreen();
  } else if (element.webkitRequestFullscreen) {
    element.webkitRequestFullscreen();
  } else if (element.mozRequestFullScreen) {
    element.mozRequestFullScreen();
  } else if (element.msRequestFullscreen) {
    element.msRequestFullscreen();
  }
}
function exitFullscreen() {
  if (document.exitFullscreen) {
    document.exitFullscreen();
  } else if (document.webkitExitFullscreen) {
    document.webkitExitFullscreen();
  } else if (document.mozCancelFullScreen) {
    document.mozCancelFullScreen();
  } else if (document.msExitFullscreen) {
    document.msExitFullscreen();
  }
}
function getFullscreenElement() {
  return document.fullscreenElement || document.webkitFullscreenElement || document.mozFullScreenElement || document.msFullscreenElement || null;
}

// src/modules/full-screen.ts
var FullScreen = {
  detectFullscreenSupport,
  enterFullscreen,
  exitFullscreen,
  getFullscreenElement
};
var full_screen_default = FullScreen;

// node_modules/@butility/network/network.js
async function ajaxFetch(options) {
  const config = {
    method: options.method,
    headers: options.headers,
    body: options.method !== "GET" ? formatDataForFetch(options.data, options.headers) : void 0,
    signal: options.abortSignal
  };
  try {
    const response = await fetch(options.url, config);
    const responseBody = await handleFetchResponse(
      response,
      options.responseType
    );
    if (options.success) options.success(responseBody);
  } catch (error) {
    handleError(options, error);
  }
}
function ajaxXHR(options) {
  const xhr = new XMLHttpRequest();
  xhr.open(options.method, options.url, true);
  if (options.headers) {
    for (const [key, value] of Object.entries(options.headers)) {
      xhr.setRequestHeader(key, value);
    }
  }
  if (options.responseType) {
    xhr.responseType = options.responseType;
  }
  if (options.timeout) {
    xhr.timeout = options.timeout;
  }
  if (options.onProgress) {
    xhr.onprogress = (event) => {
      options.onProgress(event.loaded, event.total);
    };
  }
  xhr.onload = function() {
    if (xhr.status >= 200 && xhr.status < 300) {
      if (options.success) {
        const response = options.responseType === "json" ? xhr.response : xhr.responseText;
        options.success(response);
      }
    } else {
      handleError(
        options,
        `Request failed with status ${xhr.status}: ${xhr.statusText}`
      );
    }
  };
  xhr.onerror = function() {
    handleError(options, "Request failed due to network error.");
  };
  xhr.ontimeout = function() {
    handleError(options, `Request timed out after ${xhr.timeout}ms`);
  };
  retryRequest(xhr, options);
  const requestData = formatDataForXHR(options.data, options.headers);
  xhr.send(requestData);
}
async function handleFetchResponse(response, responseType) {
  if (!response.ok) {
    throw new Error(`HTTP error: ${response.status}`);
  }
  switch (responseType) {
    case "json":
      return await response.json();
    case "blob":
      return await response.blob();
    case "arraybuffer":
      return await response.arrayBuffer();
    default:
      return await response.text();
  }
}
function formatDataForFetch(data, headers) {
  if (data && typeof data === "object" && !(data instanceof FormData)) {
    if (headers && headers["Content-Type"] === "application/json") {
      return JSON.stringify(data);
    }
  }
  return data;
}
function handleError(options, error) {
  if (options.error) {
    options.error(error);
  } else {
    console.error(error);
  }
}
function retryRequest(xhr, options, attempt = 1) {
  xhr.onloadend = () => {
    if (xhr.status >= 400 && attempt <= (options.retries || 1)) {
      setTimeout(() => {
        console.warn(
          `Retrying request... (${attempt}/${options.retries})`
        );
        ajaxXHR({ ...options, retries: options.retries - 1 });
      }, options.retryDelay || 1e3);
    }
  };
}
function formatDataForXHR(data, headers) {
  if (data && typeof data === "object" && !(data instanceof FormData)) {
    if (headers && headers["Content-Type"] === "application/json") {
      return JSON.stringify(data);
    }
  }
  return data;
}
function ajax(options) {
  if (options.useFetch) {
    return ajaxFetch(options);
  } else {
    return ajaxXHR(options);
  }
}
function get(url, data = {}, options = {}) {
  const queryString = Object.entries(data).map(
    ([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`
  ).join("&");
  const fullUrl = queryString ? `${url}?${queryString}` : url;
  return ajax({
    method: "GET",
    url: fullUrl,
    ...options
  });
}
function post(url, data, options = {}) {
  return ajax({
    method: "POST",
    url,
    data,
    headers: { "Content-Type": "application/json" },
    ...options
  });
}
function put(url, data, options = {}) {
  return ajax({
    method: "PUT",
    url,
    data,
    headers: { "Content-Type": "application/json" },
    ...options
  });
}
function patch(url, data, options = {}) {
  return ajax({
    method: "PATCH",
    url,
    data,
    headers: { "Content-Type": "application/json" },
    ...options
  });
}
function deleteRequest(url, data = {}, options = {}) {
  const queryString = Object.entries(data).map(
    ([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`
  ).join("&");
  const fullUrl = queryString ? `${url}?${queryString}` : url;
  return ajax({
    method: "DELETE",
    url: fullUrl,
    ...options
  });
}
var Request = {
  ajax,
  get,
  patch,
  post,
  put,
  deleteRequest
};
var request_default = Request;

// src/core/file.ts
function validateFileType(file, allowedTypes, allowedExtensions) {
  const fileType = file.type;
  const fileName = file.name;
  const fileExtension = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
  const mimeTypeValid = allowedTypes.some((typePattern) => {
    const regex = new RegExp(`^${typePattern.replace("*", ".*")}$`);
    return regex.test(fileType);
  });
  const extensionValid = allowedExtensions.includes(fileExtension);
  if (!mimeTypeValid || !extensionValid) {
    console.error(
      `File type or extension not allowed. Got type: ${fileType}, extension: ${fileExtension}`
    );
    return false;
  }
  return true;
}
function validateFileSize(file, maxSize) {
  return file.size <= maxSize;
}
function uploadFile(file, url) {
  return new Promise((resolve, reject) => {
    const formData = new FormData();
    formData.append("file", file);
    request_default.post(url, formData, {
      useFetch: true,
      success: (response) => {
        if (response) {
          resolve(response);
        } else {
          reject(new Error("File upload failed"));
        }
      }
    });
  });
}
async function downloadFile(fileUrl, fileName, fileType) {
  return new Promise((resolve, reject) => {
    request_default.get(fileUrl, {}, {
      useFetch: true,
      success: (response) => {
        if (response) {
          const blob = new Blob(
            [response],
            fileType ? { type: fileType } : {}
          );
          downloadBlob(blob, fileName);
          resolve(response);
        } else {
          reject(new Error(`Failed to download file.`));
        }
      }
    });
  });
}
async function unzip(zipBlob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = async (event) => {
      const arrayBuffer = event.target?.result;
      const extractedFiles = [];
      try {
        const view = new DataView(arrayBuffer);
        let offset = 0;
        while (offset < view.byteLength) {
          const signature = view.getUint32(offset, true);
          if (signature !== 67324752) {
            throw new Error("Invalid ZIP file format.");
          }
          const fileNameLength = view.getUint16(offset + 26, true);
          const extraFieldLength = view.getUint16(offset + 28, true);
          const fileNameStart = offset + 30;
          const fileName = new TextDecoder().decode(
            new Uint8Array(
              arrayBuffer,
              fileNameStart,
              fileNameLength
            )
          );
          const compressedSize = view.getUint32(offset + 18, true);
          const fileDataStart = fileNameStart + fileNameLength + extraFieldLength;
          const fileDataEnd = fileDataStart + compressedSize;
          const compressionMethod = view.getUint16(offset + 8, true);
          let fileContent;
          if (compressionMethod === 0) {
            fileContent = arrayBuffer.slice(
              fileDataStart,
              fileDataEnd
            );
          } else if (compressionMethod === 8) {
            const compressedData = arrayBuffer.slice(
              fileDataStart,
              fileDataEnd
            );
            fileContent = await decompressDEFLATE(compressedData);
          } else {
            throw new Error(
              `Unsupported compression method: ${compressionMethod}`
            );
          }
          extractedFiles.push(new File([fileContent], fileName));
          offset = fileDataEnd;
        }
        resolve(extractedFiles);
      } catch (error) {
        reject(
          new Error(
            `Failed to parse ZIP file: ${error.message}`
          )
        );
      }
    };
    reader.onerror = () => {
      reject(new Error("Error reading ZIP Blob."));
    };
    reader.readAsArrayBuffer(zipBlob);
  });
}
async function decompressDEFLATE(compressedData) {
  const decompressedChunks = [];
  if (typeof DecompressionStream === "undefined") {
    throw new Error(
      "DecompressionStream is not supported in this browser."
    );
  }
  const decompressionStream = new DecompressionStream("deflate");
  const writer = decompressionStream.writable.getWriter();
  const reader = decompressionStream.readable.getReader();
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue(new Uint8Array(compressedData));
      controller.close();
    }
  });
  await stream.pipeTo(decompressionStream.writable);
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    if (value) decompressedChunks.push(value);
  }
  const totalLength = decompressedChunks.reduce(
    (sum, chunk) => sum + chunk.length,
    0
  );
  const decompressedArray = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of decompressedChunks) {
    decompressedArray.set(chunk, offset);
    offset += chunk.length;
  }
  return decompressedArray.buffer;
}
async function zip(files, zipFileName) {
  const zipData = [];
  for (const file of files) {
    const content = new Uint8Array(await file.arrayBuffer());
    zipData.push({
      name: file.name,
      content,
      contentLength: content.length
    });
  }
  const centralDirectory = [];
  let currentOffset = 0;
  zipData.forEach((file) => {
    centralDirectory.push({
      name: file.name,
      offset: currentOffset,
      contentLength: file.contentLength
    });
    currentOffset += file.contentLength;
  });
  const zipArray = [];
  zipData.forEach((file) => {
    const header = new Uint8Array([
      80,
      75,
      3,
      4,
      // local file header signature
      10,
      0,
      // version needed to extract
      0,
      0,
      // general purpose bit flag
      0,
      0,
      // compression method (0 = store)
      0,
      0,
      0,
      0,
      // file modification time/date
      0,
      0,
      0,
      0,
      file.contentLength & 255,
      file.contentLength >> 8 & 255,
      // compressed size
      file.contentLength & 255,
      file.contentLength >> 8 & 255,
      // uncompressed size
      file.name.length & 255,
      file.name.length >> 8 & 255,
      // file name length
      0,
      0
      // extra field length
    ]);
    const nameEncoded = new TextEncoder().encode(file.name);
    const localFileHeader = new Uint8Array(
      header.length + nameEncoded.length + file.content.length
    );
    localFileHeader.set(header);
    localFileHeader.set(nameEncoded, header.length);
    localFileHeader.set(file.content, header.length + nameEncoded.length);
    zipArray.push(localFileHeader);
  });
  const centralDirectoryArray = [];
  centralDirectory.forEach((file) => {
    const header = new Uint8Array([
      80,
      75,
      1,
      2,
      // central file header signature
      10,
      0,
      // version made by
      10,
      0,
      // version needed to extract
      0,
      0,
      // general purpose bit flag
      0,
      0,
      // compression method
      0,
      0,
      0,
      0,
      // file modification time/date
      0,
      0,
      0,
      0,
      // CRC-32
      file.contentLength & 255,
      file.contentLength >> 8 & 255,
      // compressed size
      file.contentLength & 255,
      file.contentLength >> 8 & 255,
      // uncompressed size
      file.name.length & 255,
      file.name.length >> 8 & 255,
      // file name length
      0,
      0,
      // extra field length
      0,
      0,
      // file comment length
      0,
      0,
      // disk number start
      0,
      0,
      // internal file attributes
      0,
      0,
      0,
      0,
      // external file attributes
      file.offset & 255,
      file.offset >> 8 & 255,
      file.offset >> 16 & 255,
      file.offset >> 24 & 255
      // relative offset of local header
    ]);
    const nameEncoded = new TextEncoder().encode(file.name);
    const centralFileHeader = new Uint8Array(
      header.length + nameEncoded.length
    );
    centralFileHeader.set(header);
    centralFileHeader.set(nameEncoded, header.length);
    centralDirectoryArray.push(centralFileHeader);
  });
  const endOfCentralDirectory = new Uint8Array([
    80,
    75,
    5,
    6,
    // end of central directory signature
    0,
    0,
    // number of this disk
    0,
    0,
    // disk where central directory starts
    centralDirectory.length & 255,
    centralDirectory.length >> 8 & 255,
    // total number of entries on this disk
    centralDirectory.length & 255,
    centralDirectory.length >> 8 & 255,
    // total number of entries overall
    centralDirectoryArray.reduce((acc, entry) => acc + entry.length, 0) & 255,
    // size of central directory
    currentOffset & 255,
    currentOffset >> 8 & 255,
    currentOffset >> 16 & 255,
    currentOffset >> 24 & 255,
    // offset of start of central directory
    0,
    0
    // zip file comment length
  ]);
  const totalLength = zipArray.reduce((acc, entry) => acc + entry.length, 0) + centralDirectoryArray.reduce((acc, entry) => acc + entry.length, 0) + endOfCentralDirectory.length;
  const zipFile = new Uint8Array(totalLength);
  currentOffset = 0;
  zipArray.forEach((entry) => {
    zipFile.set(entry, currentOffset);
    currentOffset += entry.length;
  });
  centralDirectoryArray.forEach((entry) => {
    zipFile.set(entry, currentOffset);
    currentOffset += entry.length;
  });
  zipFile.set(endOfCentralDirectory, currentOffset);
  const zipBlob = new Blob([zipFile], { type: "application/zip" });
  downloadBlob(zipBlob, zipFileName);
  return zipBlob;
}

// src/modules/file.ts
var File2 = {
  decompressDEFLATE,
  downloadFile,
  unzip,
  uploadFile,
  validateFileSize,
  validateFileType,
  zip
};
var file_default = File2;

// src/core/audiovisual/caption.ts
function toggleCaptions(videoElement) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (!videoElement.textTracks) {
      return reject(
        new Error("The video element does not support text tracks.")
      );
    }
    try {
      const textTracks = Array.from(videoElement.textTracks);
      const hasVisibleCaptions = textTracks.some(
        (track) => track.mode === "showing"
      );
      if (hasVisibleCaptions) {
        textTracks.forEach((track) => track.mode = "hidden");
        console.log("Captions turned off.");
      } else {
        textTracks.forEach((track) => track.mode = "showing");
        console.log("Captions turned on.");
      }
      resolve();
    } catch (error) {
      reject(new Error("Error toggling captions: " + error.message));
    }
  });
}
function setCaptionTrack(videoElement, trackIndex) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (!videoElement.textTracks) {
      return reject(
        new Error("The video element does not support text tracks.")
      );
    }
    const textTracks = Array.from(videoElement.textTracks);
    if (trackIndex < 0 || trackIndex >= textTracks.length) {
      return reject(
        new Error(
          "Invalid trackIndex. It must be within the range of available tracks."
        )
      );
    }
    try {
      textTracks.forEach((track, index) => {
        track.mode = index === trackIndex ? "showing" : "hidden";
      });
      console.log(`Caption track set to index ${trackIndex}.`);
      resolve();
    } catch (error) {
      reject(new Error("Error setting caption track: " + error.message));
    }
  });
}
function getAvailableCaptionTracks(videoElement) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (!videoElement.textTracks) {
      return reject(
        new Error("The video element does not support text tracks.")
      );
    }
    try {
      const textTracks = Array.from(videoElement.textTracks);
      const availableTracks = textTracks.filter(
        (track) => track.kind === "subtitles" || track.kind === "captions"
      );
      console.log(`Available caption tracks: ${availableTracks.length}`);
      resolve(availableTracks);
    } catch (error) {
      reject(
        new Error("Error retrieving caption tracks: " + error.message)
      );
    }
  });
}

// src/core/audiovisual/seek.ts
function seekTo(videoElement, timeInSeconds) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (typeof timeInSeconds !== "number" || isNaN(timeInSeconds) || timeInSeconds < 0) {
      return reject(
        new Error(
          "Invalid timeInSeconds. Must be a non-negative number."
        )
      );
    }
    if (isNaN(videoElement.duration)) {
      return reject(
        new Error(
          "The video duration is not available. Ensure the video metadata has loaded."
        )
      );
    }
    const seekTime = Math.min(
      Math.max(timeInSeconds, 0),
      videoElement.duration
    );
    try {
      videoElement.currentTime = seekTime;
      resolve();
    } catch (error) {
      reject(
        new Error(
          "Error attempting to seek to the specified time: " + error.message
        )
      );
    }
  });
}
function skipWithDir(videoElement, seconds, direction) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (typeof seconds !== "number" || isNaN(seconds) || seconds <= 0) {
      return reject(
        new Error("Invalid seconds. Must be a positive number.")
      );
    }
    if (isNaN(videoElement.duration)) {
      return reject(
        new Error(
          "The video duration is not available. Ensure the video metadata has loaded."
        )
      );
    }
    let newTime;
    switch (direction) {
      case "forward":
        newTime = videoElement.currentTime + seconds;
        break;
      case "backward":
        newTime = videoElement.currentTime - seconds;
        break;
      default:
        return reject(
          new Error(
            'Invalid direction. Use "forward" or "backward".'
          )
        );
    }
    newTime = Math.max(0, Math.min(newTime, videoElement.duration));
    try {
      videoElement.currentTime = newTime;
      resolve();
    } catch (error) {
      reject(
        new Error(
          "Error attempting to skip to the specified time: " + error.message
        )
      );
    }
  });
}

// src/core/audiovisual/edit.ts
function videoTones(videoElement, options) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (typeof options !== "object" || Array.isArray(options)) {
      return reject(
        new Error("Invalid options object. Must be a plain object.")
      );
    }
    const applyCSSProperty = (property, value, defaultValue) => {
      if (value === null) {
        videoElement.style[property] = defaultValue;
      } else {
        videoElement.style[property] = value;
      }
    };
    try {
      if (options.brightness !== void 0) {
        applyCSSProperty(
          "filter",
          `brightness(${options.brightness})`,
          "none"
        );
      }
      if (options.contrast !== void 0) {
        applyCSSProperty(
          "filter",
          `contrast(${options.contrast})`,
          "none"
        );
      }
      if (options.saturation !== void 0) {
        applyCSSProperty(
          "filter",
          `saturate(${options.saturation})`,
          "none"
        );
      }
      if (options.filter !== void 0) {
        if (typeof options.filter !== "string") {
          return reject(new Error("filter must be a string."));
        }
        videoElement.style.filter = options.filter;
      }
      const filterParts = [];
      if (options.brightness !== void 0)
        filterParts.push(`brightness(${options.brightness})`);
      if (options.contrast !== void 0)
        filterParts.push(`contrast(${options.contrast})`);
      if (options.saturation !== void 0)
        filterParts.push(`saturate(${options.saturation})`);
      if (options.filter) filterParts.push(options.filter);
      if (filterParts.length > 0) {
        videoElement.style.filter = filterParts.join(" ");
      }
      resolve();
    } catch (error) {
      reject(
        new Error("Error applying video adjustments: " + error.message)
      );
    }
  });
}
function updateVideoSourceAndResolution(videoElement, sourceUrl, type, resolution) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (typeof sourceUrl !== "string" || !sourceUrl.trim()) {
      return reject(
        new Error("Invalid sourceUrl. Must be a non-empty string.")
      );
    }
    const validTypes = [
      "video/mp4",
      "video/webm",
      "video/avi",
      "video/mkv",
      "video/mov",
      "video/flv",
      "video/wmv",
      "video/m4v",
      "video/ogg"
    ];
    if (!validTypes.includes(`video/${type}`)) {
      return reject(
        new Error(
          'Invalid type. Must be one of the following: "mp4", "webm", "avi", "mkv", "mov", "flv", "wmv", "m4v", "ogg"'
        )
      );
    }
    let width;
    let height;
    if (resolution) {
      if (typeof resolution !== "string" || !/^\d+x\d+$/.test(resolution)) {
        return reject(
          new Error(
            'Invalid resolution format. Must be in the format "widthxheight" (e.g., "1920x1080").'
          )
        );
      }
      [width, height] = resolution.split("x").map(Number);
      if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
        return reject(
          new Error(
            "Invalid resolution values. Width and height must be positive numbers."
          )
        );
      }
    }
    const sourceElement = source({ src: sourceUrl, type });
    setAttribute2(videoElement, { innerHTML: "" });
    videoElement.innerHTML = "";
    videoElement.appendChild(sourceElement);
    videoElement.load();
    if (width && height) {
      videoElement.style.width = `${width}px`;
      videoElement.style.height = `${height}px`;
    }
    videoElement.oncanplay = () => {
      resolve();
    };
    videoElement.onerror = (error) => {
      reject(
        new Error("Error loading the video source: " + error.message)
      );
    };
  });
}

// src/core/audiovisual/event.ts
function registerVideoEvents(videoElement, callbacks) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (typeof callbacks !== "object" || Array.isArray(callbacks)) {
      return reject(
        new Error("Invalid callbacks object. Must be a plain object.")
      );
    }
    const attachEventListener = (eventType, callback) => {
      if (callback && typeof callback === "function") {
        videoElement.addEventListener(eventType, (event) => {
          try {
            if (eventType === "timeupdate") {
              callback(
                event.target.currentTime
              );
            } else {
              callback();
            }
          } catch (error) {
            console.error(`Error in ${eventType} callback:`, error);
          }
        });
      } else if (callback !== void 0) {
        console.warn(
          `Callback for ${eventType} is not a function or is missing.`
        );
      }
    };
    try {
      attachEventListener("play", callbacks.onPlay);
      attachEventListener("pause", callbacks.onPause);
      attachEventListener("timeupdate", callbacks.onTimeUpdate);
      attachEventListener("ended", callbacks.onEnd);
      resolve();
    } catch (error) {
      reject(
        new Error(
          "Error registering video event listeners: " + error.message
        )
      );
    }
  });
}

// src/core/audiovisual/controls.ts
function controlPlayback(videoElement, action) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    switch (action) {
      case "play":
        if (videoElement.paused) {
          videoElement.play().then(() => resolve()).catch(
            (error) => reject(
              new Error(
                "Error attempting to play the video: " + error.message
              )
            )
          );
        } else {
          resolve();
        }
        break;
      case "pause":
        if (!videoElement.paused) {
          videoElement.pause();
          resolve();
        } else {
          resolve();
        }
        break;
      case "toggle":
        if (videoElement.paused) {
          videoElement.play().then(() => resolve()).catch(
            (error) => reject(
              new Error(
                "Error attempting to play the video: " + error.message
              )
            )
          );
        } else {
          videoElement.pause();
          resolve();
        }
        break;
      default:
        reject(
          new Error(
            'Invalid action. Use "play", "pause", or "toggle".'
          )
        );
        break;
    }
  });
}
function controlVolume(videoElement, action, volumeLevel) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    switch (action) {
      case "setVolume":
        if (typeof volumeLevel !== "number" || isNaN(volumeLevel) || volumeLevel < 0 || volumeLevel > 1) {
          return reject(
            new Error(
              "Invalid volumeLevel. Must be a number between 0 and 1."
            )
          );
        }
        videoElement.volume = volumeLevel;
        videoElement.muted = false;
        resolve();
        break;
      case "mute":
        videoElement.muted = true;
        resolve();
        break;
      case "unmute":
        videoElement.muted = false;
        resolve();
        break;
      case "toggleMute":
        videoElement.muted = !videoElement.muted;
        resolve();
        break;
      default:
        reject(
          new Error(
            'Invalid action. Use "setVolume", "mute", "unmute", or "toggleMute".'
          )
        );
        break;
    }
  });
}

// src/modules/audiovisual.ts
var Audiovisual = {
  controlPlayback,
  controlVolume,
  getAvailableCaptionTracks,
  registerVideoEvents,
  seekTo,
  setCaptionTrack,
  skipWithDir,
  toggleCaptions,
  updateVideoSourceAndResolution,
  videoTones
};
var audiovisual_default = Audiovisual;

// src/index.ts
var Media = {
  blobToHex,
  calculateAspectRatio,
  capturePhoto,
  chunkBlob,
  compressImage,
  controlPlayback,
  controlVolume,
  convertBase64ToBlob,
  convertBlobToBase64,
  convertImageToBase64,
  cropImage,
  decompressDEFLATE,
  decryptBlob,
  detectFullscreenSupport,
  downloadBlob,
  downloadFile,
  encryptBlob,
  enterFullscreen,
  exitFullscreen,
  flipImage,
  getAvailableCaptionTracks,
  getFullscreenElement,
  mergeBlobs,
  openCamera,
  preloadImagesWithCallback,
  readBlobAsText,
  recordVideo,
  registerVideoEvents,
  resizeImage,
  rotateImage,
  seekTo,
  setCaptionTrack,
  skipWithDir,
  textToBlob,
  toggleCaptions,
  unzip,
  updateVideoSourceAndResolution,
  uploadFile,
  validateFileSize,
  validateFileType,
  verifyBlob,
  videoTones,
  zip
};
var src_default = Media;
export {
  audiovisual_default as Audiovisual,
  blob_default as Blob,
  camera_default as Camera,
  file_default as File,
  full_screen_default as FullScreen,
  image_default as Image,
  blobToHex,
  calculateAspectRatio,
  capturePhoto,
  chunkBlob,
  compressImage,
  controlPlayback,
  controlVolume,
  convertBase64ToBlob,
  convertBlobToBase64,
  convertImageToBase64,
  cropImage,
  decompressDEFLATE,
  decryptBlob,
  src_default as default,
  detectFullscreenSupport,
  downloadBlob,
  downloadFile,
  encryptBlob,
  enterFullscreen,
  exitFullscreen,
  flipImage,
  getAvailableCaptionTracks,
  getFullscreenElement,
  mergeBlobs,
  openCamera,
  preloadImagesWithCallback,
  readBlobAsText,
  recordVideo,
  registerVideoEvents,
  resizeImage,
  rotateImage,
  seekTo,
  setCaptionTrack,
  skipWithDir,
  textToBlob,
  toggleCaptions,
  unzip,
  updateVideoSourceAndResolution,
  uploadFile,
  validateFileSize,
  validateFileType,
  verifyBlob,
  videoTones,
  zip
};
