// src/core/audiovisual/caption.ts
function toggleCaptions(videoElement) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (!videoElement.textTracks) {
      return reject(
        new Error("The video element does not support text tracks.")
      );
    }
    try {
      const textTracks = Array.from(videoElement.textTracks);
      const hasVisibleCaptions = textTracks.some(
        (track) => track.mode === "showing"
      );
      if (hasVisibleCaptions) {
        textTracks.forEach((track) => track.mode = "hidden");
        console.log("Captions turned off.");
      } else {
        textTracks.forEach((track) => track.mode = "showing");
        console.log("Captions turned on.");
      }
      resolve();
    } catch (error) {
      reject(new Error("Error toggling captions: " + error.message));
    }
  });
}
function setCaptionTrack(videoElement, trackIndex) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (!videoElement.textTracks) {
      return reject(
        new Error("The video element does not support text tracks.")
      );
    }
    const textTracks = Array.from(videoElement.textTracks);
    if (trackIndex < 0 || trackIndex >= textTracks.length) {
      return reject(
        new Error(
          "Invalid trackIndex. It must be within the range of available tracks."
        )
      );
    }
    try {
      textTracks.forEach((track, index) => {
        track.mode = index === trackIndex ? "showing" : "hidden";
      });
      console.log(`Caption track set to index ${trackIndex}.`);
      resolve();
    } catch (error) {
      reject(new Error("Error setting caption track: " + error.message));
    }
  });
}
function getAvailableCaptionTracks(videoElement) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (!videoElement.textTracks) {
      return reject(
        new Error("The video element does not support text tracks.")
      );
    }
    try {
      const textTracks = Array.from(videoElement.textTracks);
      const availableTracks = textTracks.filter(
        (track) => track.kind === "subtitles" || track.kind === "captions"
      );
      console.log(`Available caption tracks: ${availableTracks.length}`);
      resolve(availableTracks);
    } catch (error) {
      reject(
        new Error("Error retrieving caption tracks: " + error.message)
      );
    }
  });
}

// src/core/audiovisual/seek.ts
function seekTo(videoElement, timeInSeconds) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (typeof timeInSeconds !== "number" || isNaN(timeInSeconds) || timeInSeconds < 0) {
      return reject(
        new Error(
          "Invalid timeInSeconds. Must be a non-negative number."
        )
      );
    }
    if (isNaN(videoElement.duration)) {
      return reject(
        new Error(
          "The video duration is not available. Ensure the video metadata has loaded."
        )
      );
    }
    const seekTime = Math.min(
      Math.max(timeInSeconds, 0),
      videoElement.duration
    );
    try {
      videoElement.currentTime = seekTime;
      resolve();
    } catch (error) {
      reject(
        new Error(
          "Error attempting to seek to the specified time: " + error.message
        )
      );
    }
  });
}
function skipWithDir(videoElement, seconds, direction) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (typeof seconds !== "number" || isNaN(seconds) || seconds <= 0) {
      return reject(
        new Error("Invalid seconds. Must be a positive number.")
      );
    }
    if (isNaN(videoElement.duration)) {
      return reject(
        new Error(
          "The video duration is not available. Ensure the video metadata has loaded."
        )
      );
    }
    let newTime;
    switch (direction) {
      case "forward":
        newTime = videoElement.currentTime + seconds;
        break;
      case "backward":
        newTime = videoElement.currentTime - seconds;
        break;
      default:
        return reject(
          new Error(
            'Invalid direction. Use "forward" or "backward".'
          )
        );
    }
    newTime = Math.max(0, Math.min(newTime, videoElement.duration));
    try {
      videoElement.currentTime = newTime;
      resolve();
    } catch (error) {
      reject(
        new Error(
          "Error attempting to skip to the specified time: " + error.message
        )
      );
    }
  });
}

// node_modules/@butility/dom/html.js
function create(name, options = {}, callback) {
  const element = document.createElement(name);
  if (options.class && Array.isArray(options.class)) {
    options.class.forEach((className) => {
      if (className) {
        element.classList.add(className);
      }
    });
  }
  if (options.attr) {
    for (const key in options.attr) {
      if (Object.hasOwnProperty.call(options.attr, key)) {
        element.setAttribute(key, options.attr[key]);
      }
    }
  }
  if (options.innerText) element.innerText = options.innerText;
  if (options.innerHTML) element.innerHTML = options.innerHTML;
  if (options.children && Array.isArray(options.children)) {
    options.children.forEach((child) => {
      if (child instanceof HTMLElement) {
        element.appendChild(child);
      }
    });
  }
  if (options.draggable) element.draggable = true;
  if (options.style) element.style.cssText = options.style;
  if (options.trackMutation) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        console.log("Mutation observed:", mutation);
      });
    });
    observer.observe(element, { attributes: true, childList: true, subtree: true });
  }
  if (callback && typeof callback === "function") callback(element);
  return element;
}
function setAttribute(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(attribute)) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log) console.log(`Skipping attribute: ${finalAttributeName}`);
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(`Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`);
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log) console.log(`Set data attribute: data-${dataKey} = ${transformedValue}`);
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log) console.log(`Set attribute: ${finalAttributeName} = ${transformedValue}`);
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}
function setAttributeOrChildren(element, ...attributesOrChildren) {
  attributesOrChildren.forEach((item) => {
    if (typeof item === "object" && !(item instanceof HTMLElement)) {
      setAttribute(element, item);
    } else if (item instanceof HTMLElement || typeof item === "string") {
      element.append(item);
    }
  });
}
function source(...attributesOrChildren) {
  const element = create("source");
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}

// node_modules/@butility/dom/attribute.js
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var attribute_exports = {};
__export(attribute_exports, {
  attributesToQueryString: () => attributesToQueryString,
  compareAttributes: () => compareAttributes,
  copyAttributes: () => copyAttributes,
  findElementByAttribute: () => findElementByAttribute,
  getAllAttributes: () => getAllAttributes,
  getAttribute: () => getAttribute,
  getAttributesByPrefix: () => getAttributesByPrefix,
  hasAnyAttributes: () => hasAnyAttributes,
  hasAttribute: () => hasAttribute,
  removeAllAttributes: () => removeAllAttributes,
  removeAttribute: () => removeAttribute,
  removeAttributesByName: () => removeAttributesByName,
  removeAttributesByPrefix: () => removeAttributesByPrefix,
  setAttribute: () => setAttribute2,
  setAttributesFromQueryString: () => setAttributesFromQueryString,
  toggleAttribute: () => toggleAttribute,
  toggleAttributes: () => toggleAttributes
});
function setAttribute2(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(attribute)) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log) console.log(`Skipping attribute: ${finalAttributeName}`);
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(`Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`);
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log) console.log(`Set data attribute: data-${dataKey} = ${transformedValue}`);
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log) console.log(`Set attribute: ${finalAttributeName} = ${transformedValue}`);
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}
function removeAttribute(element, attributeName) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  if (/^data-/.test(attributeName)) {
    delete element.dataset[attributeName.slice(5)];
  } else if (element.hasAttribute(attributeName)) {
    element.removeAttribute(attributeName);
  } else {
    console.warn(`Attribute "${attributeName}" does not exist on`, element);
  }
}
function getAttribute(element, attributeName, options) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const result = {};
  let value;
  if (options?.dataPrefix && /^data-/.test(attributeName)) {
    value = element.dataset[attributeName.slice(5)] || null;
  } else {
    value = element.getAttribute(attributeName);
  }
  if (options?.transform) {
    value = options.transform(value);
  }
  result[attributeName] = value !== null ? value : options?.defaultValue || null;
  return result;
}
function getAllAttributes(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const attributes = {};
  Array.from(element.attributes).forEach((attr) => {
    attributes[attr.name] = attr.value;
  });
  Object.keys(element.dataset).forEach((dataKey) => {
    const dataValue = element.dataset[dataKey];
    if (dataValue !== void 0) {
      attributes[`data-${dataKey}`] = dataValue;
    }
  });
  return attributes;
}
function hasAttribute(element, attributeName) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  return /^data-/.test(attributeName) ? attributeName.slice(5) in element.dataset : element.hasAttribute(attributeName);
}
function toggleAttribute(element, attributeName, attributeValue) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  if (hasAttribute(element, attributeName)) {
    removeAttribute(element, attributeName);
  } else {
    setAttribute2(element, {
      [attributeName]: attributeValue
    });
  }
}
function removeAllAttributes(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  Array.from(element.attributes).forEach((attr) => {
    element.removeAttribute(attr.name);
  });
  Object.keys(element.dataset).forEach((dataKey) => {
    delete element.dataset[dataKey];
  });
}
function attributesToQueryString(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const attributes = Array.from(element.attributes);
  return attributes.map((attr) => `${encodeURIComponent(attr.name)}=${encodeURIComponent(attr.value)}`).join("&");
}
function copyAttributes(element, target) {
  if (!element || !(element instanceof HTMLElement) || !target || !(target instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  Array.from(element.attributes).forEach((attr) => {
    setAttribute2(target, { [attr.name]: attr.value });
  });
}
function findElementByAttribute(Element, attributeName) {
  return Array.from(Element.querySelectorAll(`[${attributeName}]`));
}
function toggleAttributes(element, attributes) {
  Object.keys(attributes).forEach((attr) => {
    if (attributes[attr]) {
      element.setAttribute(attr, "");
    } else {
      element.removeAttribute(attr);
    }
  });
}
function hasAnyAttributes(element) {
  return element.attributes.length > 0;
}
function removeAttributesByName(element, ...attributeNames) {
  attributeNames.forEach((attr) => {
    element.removeAttribute(attr);
  });
}
function getAttributesByPrefix(element, prefix) {
  const result = {};
  Array.from(element.attributes).forEach((attr) => {
    if (attr.name.startsWith(prefix)) {
      result[attr.name] = attr.value;
    }
  });
  return result;
}
function setAttributesFromQueryString(element, queryString, options = {}) {
  const {
    onError = (error) => console.error(error)
  } = options;
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof queryString !== "string" || !queryString.trim()) {
      throw new Error("Invalid queryString provided. It must be a non-empty string.");
    }
    const params = new URLSearchParams(queryString);
    try {
      setAttribute2(element, params, options);
    } catch (attrError) {
      onError(attrError);
    }
  } catch (error) {
    onError(error);
  }
}
function compareAttributes(el1, el2, options = {}) {
  const diff = {};
  try {
    if (!(el1 instanceof HTMLElement) || !(el2 instanceof HTMLElement)) {
      throw new TypeError("Both el1 and el2 must be valid HTMLElements.");
    }
    const el1Attributes = el1.attributes;
    const el2Attributes = el2.attributes;
    const {
      onTrue = () => {
      },
      // Default no-op callback if not provided
      onFalse = () => {
      },
      // Default no-op callback if not provided
      ignoreAttributes = [],
      customCompare
    } = options;
    const shouldIgnore = (attrName) => ignoreAttributes.includes(attrName);
    Array.from(el1Attributes).forEach((attr) => {
      const el2Value = el2.getAttribute(attr.name);
      if (shouldIgnore(attr.name)) return;
      const isEqual = customCompare ? customCompare(attr.value, el2Value) : attr.value === el2Value;
      if (!isEqual) {
        diff[attr.name] = { el1Value: attr.value, el2Value };
        onFalse(attr.name, attr.value, el2Value);
      } else {
        onTrue(attr.name, attr.value, el2Value);
      }
    });
    Array.from(el2Attributes).forEach((attr) => {
      if (!el1.hasAttribute(attr.name) && !shouldIgnore(attr.name)) {
        diff[attr.name] = { el1Value: null, el2Value: attr.value };
        onFalse(attr.name, null, attr.value);
      }
    });
  } catch (error) {
    console.error(`Error comparing attributes: ${error.message}`);
  }
  return diff;
}
function removeAttributesByPrefix(element, prefixes, options) {
  const { onRemove, protectedAttr } = options;
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    const prefixList = Array.isArray(prefixes) ? prefixes : [prefixes];
    if (prefixList.length === 0 || prefixList.some((prefix) => typeof prefix !== "string" || !prefix.trim())) {
      throw new Error("Invalid prefixes provided. Prefixes must be non-empty strings.");
    }
    Array.from(element.attributes).forEach((attr) => {
      const attrName = attr.name;
      const shouldRemove = prefixList.some((prefix) => attrName.startsWith(prefix));
      if (shouldRemove) {
        if (typeof onRemove === "function") {
          onRemove(attrName);
        }
        const isRemovable = (attrName2) => {
          if (protectedAttr) {
            return !protectedAttr.includes(attrName2);
          }
        };
        if (isRemovable(attrName) === true) {
          element.removeAttribute(attrName);
        }
      }
    });
  } catch (error) {
    console.error(`Error while removing attributes by prefix: ${error.message}`);
  }
}
var Attribute = { ...attribute_exports };

// src/core/audiovisual/edit.ts
function videoTones(videoElement, options) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (typeof options !== "object" || Array.isArray(options)) {
      return reject(
        new Error("Invalid options object. Must be a plain object.")
      );
    }
    const applyCSSProperty = (property, value, defaultValue) => {
      if (value === null) {
        videoElement.style[property] = defaultValue;
      } else {
        videoElement.style[property] = value;
      }
    };
    try {
      if (options.brightness !== void 0) {
        applyCSSProperty(
          "filter",
          `brightness(${options.brightness})`,
          "none"
        );
      }
      if (options.contrast !== void 0) {
        applyCSSProperty(
          "filter",
          `contrast(${options.contrast})`,
          "none"
        );
      }
      if (options.saturation !== void 0) {
        applyCSSProperty(
          "filter",
          `saturate(${options.saturation})`,
          "none"
        );
      }
      if (options.filter !== void 0) {
        if (typeof options.filter !== "string") {
          return reject(new Error("filter must be a string."));
        }
        videoElement.style.filter = options.filter;
      }
      const filterParts = [];
      if (options.brightness !== void 0)
        filterParts.push(`brightness(${options.brightness})`);
      if (options.contrast !== void 0)
        filterParts.push(`contrast(${options.contrast})`);
      if (options.saturation !== void 0)
        filterParts.push(`saturate(${options.saturation})`);
      if (options.filter) filterParts.push(options.filter);
      if (filterParts.length > 0) {
        videoElement.style.filter = filterParts.join(" ");
      }
      resolve();
    } catch (error) {
      reject(
        new Error("Error applying video adjustments: " + error.message)
      );
    }
  });
}
function updateVideoSourceAndResolution(videoElement, sourceUrl, type, resolution) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (typeof sourceUrl !== "string" || !sourceUrl.trim()) {
      return reject(
        new Error("Invalid sourceUrl. Must be a non-empty string.")
      );
    }
    const validTypes = [
      "video/mp4",
      "video/webm",
      "video/avi",
      "video/mkv",
      "video/mov",
      "video/flv",
      "video/wmv",
      "video/m4v",
      "video/ogg"
    ];
    if (!validTypes.includes(`video/${type}`)) {
      return reject(
        new Error(
          'Invalid type. Must be one of the following: "mp4", "webm", "avi", "mkv", "mov", "flv", "wmv", "m4v", "ogg"'
        )
      );
    }
    let width;
    let height;
    if (resolution) {
      if (typeof resolution !== "string" || !/^\d+x\d+$/.test(resolution)) {
        return reject(
          new Error(
            'Invalid resolution format. Must be in the format "widthxheight" (e.g., "1920x1080").'
          )
        );
      }
      [width, height] = resolution.split("x").map(Number);
      if (isNaN(width) || isNaN(height) || width <= 0 || height <= 0) {
        return reject(
          new Error(
            "Invalid resolution values. Width and height must be positive numbers."
          )
        );
      }
    }
    const sourceElement = source({ src: sourceUrl, type });
    setAttribute2(videoElement, { innerHTML: "" });
    videoElement.innerHTML = "";
    videoElement.appendChild(sourceElement);
    videoElement.load();
    if (width && height) {
      videoElement.style.width = `${width}px`;
      videoElement.style.height = `${height}px`;
    }
    videoElement.oncanplay = () => {
      resolve();
    };
    videoElement.onerror = (error) => {
      reject(
        new Error("Error loading the video source: " + error.message)
      );
    };
  });
}

// src/core/audiovisual/event.ts
function registerVideoEvents(videoElement, callbacks) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    if (typeof callbacks !== "object" || Array.isArray(callbacks)) {
      return reject(
        new Error("Invalid callbacks object. Must be a plain object.")
      );
    }
    const attachEventListener = (eventType, callback) => {
      if (callback && typeof callback === "function") {
        videoElement.addEventListener(eventType, (event) => {
          try {
            if (eventType === "timeupdate") {
              callback(
                event.target.currentTime
              );
            } else {
              callback();
            }
          } catch (error) {
            console.error(`Error in ${eventType} callback:`, error);
          }
        });
      } else if (callback !== void 0) {
        console.warn(
          `Callback for ${eventType} is not a function or is missing.`
        );
      }
    };
    try {
      attachEventListener("play", callbacks.onPlay);
      attachEventListener("pause", callbacks.onPause);
      attachEventListener("timeupdate", callbacks.onTimeUpdate);
      attachEventListener("ended", callbacks.onEnd);
      resolve();
    } catch (error) {
      reject(
        new Error(
          "Error registering video event listeners: " + error.message
        )
      );
    }
  });
}

// src/core/audiovisual/controls.ts
function controlPlayback(videoElement, action) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    switch (action) {
      case "play":
        if (videoElement.paused) {
          videoElement.play().then(() => resolve()).catch(
            (error) => reject(
              new Error(
                "Error attempting to play the video: " + error.message
              )
            )
          );
        } else {
          resolve();
        }
        break;
      case "pause":
        if (!videoElement.paused) {
          videoElement.pause();
          resolve();
        } else {
          resolve();
        }
        break;
      case "toggle":
        if (videoElement.paused) {
          videoElement.play().then(() => resolve()).catch(
            (error) => reject(
              new Error(
                "Error attempting to play the video: " + error.message
              )
            )
          );
        } else {
          videoElement.pause();
          resolve();
        }
        break;
      default:
        reject(
          new Error(
            'Invalid action. Use "play", "pause", or "toggle".'
          )
        );
        break;
    }
  });
}
function controlVolume(videoElement, action, volumeLevel) {
  return new Promise((resolve, reject) => {
    if (!(videoElement instanceof HTMLVideoElement)) {
      return reject(
        new Error(
          "The provided element is not a valid HTMLVideoElement."
        )
      );
    }
    switch (action) {
      case "setVolume":
        if (typeof volumeLevel !== "number" || isNaN(volumeLevel) || volumeLevel < 0 || volumeLevel > 1) {
          return reject(
            new Error(
              "Invalid volumeLevel. Must be a number between 0 and 1."
            )
          );
        }
        videoElement.volume = volumeLevel;
        videoElement.muted = false;
        resolve();
        break;
      case "mute":
        videoElement.muted = true;
        resolve();
        break;
      case "unmute":
        videoElement.muted = false;
        resolve();
        break;
      case "toggleMute":
        videoElement.muted = !videoElement.muted;
        resolve();
        break;
      default:
        reject(
          new Error(
            'Invalid action. Use "setVolume", "mute", "unmute", or "toggleMute".'
          )
        );
        break;
    }
  });
}

// src/modules/audiovisual.ts
var Audiovisual = {
  controlPlayback,
  controlVolume,
  getAvailableCaptionTracks,
  registerVideoEvents,
  seekTo,
  setCaptionTrack,
  skipWithDir,
  toggleCaptions,
  updateVideoSourceAndResolution,
  videoTones
};
var audiovisual_default = Audiovisual;
export {
  controlPlayback,
  controlVolume,
  audiovisual_default as default,
  getAvailableCaptionTracks,
  registerVideoEvents,
  seekTo,
  setCaptionTrack,
  skipWithDir,
  toggleCaptions,
  updateVideoSourceAndResolution,
  videoTones
};
