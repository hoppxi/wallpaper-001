// node_modules/@butility/dom/attribute.js
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var attribute_exports = {};
__export(attribute_exports, {
  attributesToQueryString: () => attributesToQueryString,
  compareAttributes: () => compareAttributes,
  copyAttributes: () => copyAttributes,
  findElementByAttribute: () => findElementByAttribute,
  getAllAttributes: () => getAllAttributes,
  getAttribute: () => getAttribute,
  getAttributesByPrefix: () => getAttributesByPrefix,
  hasAnyAttributes: () => hasAnyAttributes,
  hasAttribute: () => hasAttribute,
  removeAllAttributes: () => removeAllAttributes,
  removeAttribute: () => removeAttribute,
  removeAttributesByName: () => removeAttributesByName,
  removeAttributesByPrefix: () => removeAttributesByPrefix,
  setAttribute: () => setAttribute,
  setAttributesFromQueryString: () => setAttributesFromQueryString,
  toggleAttribute: () => toggleAttribute,
  toggleAttributes: () => toggleAttributes
});
function setAttribute(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(attribute)) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log) console.log(`Skipping attribute: ${finalAttributeName}`);
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(`Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`);
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log) console.log(`Set data attribute: data-${dataKey} = ${transformedValue}`);
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log) console.log(`Set attribute: ${finalAttributeName} = ${transformedValue}`);
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}
function removeAttribute(element, attributeName) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  if (/^data-/.test(attributeName)) {
    delete element.dataset[attributeName.slice(5)];
  } else if (element.hasAttribute(attributeName)) {
    element.removeAttribute(attributeName);
  } else {
    console.warn(`Attribute "${attributeName}" does not exist on`, element);
  }
}
function getAttribute(element, attributeName, options) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const result = {};
  let value;
  if (options?.dataPrefix && /^data-/.test(attributeName)) {
    value = element.dataset[attributeName.slice(5)] || null;
  } else {
    value = element.getAttribute(attributeName);
  }
  if (options?.transform) {
    value = options.transform(value);
  }
  result[attributeName] = value !== null ? value : options?.defaultValue || null;
  return result;
}
function getAllAttributes(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const attributes = {};
  Array.from(element.attributes).forEach((attr) => {
    attributes[attr.name] = attr.value;
  });
  Object.keys(element.dataset).forEach((dataKey) => {
    const dataValue = element.dataset[dataKey];
    if (dataValue !== void 0) {
      attributes[`data-${dataKey}`] = dataValue;
    }
  });
  return attributes;
}
function hasAttribute(element, attributeName) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  return /^data-/.test(attributeName) ? attributeName.slice(5) in element.dataset : element.hasAttribute(attributeName);
}
function toggleAttribute(element, attributeName, attributeValue) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  if (hasAttribute(element, attributeName)) {
    removeAttribute(element, attributeName);
  } else {
    setAttribute(element, {
      [attributeName]: attributeValue
    });
  }
}
function removeAllAttributes(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  Array.from(element.attributes).forEach((attr) => {
    element.removeAttribute(attr.name);
  });
  Object.keys(element.dataset).forEach((dataKey) => {
    delete element.dataset[dataKey];
  });
}
function attributesToQueryString(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const attributes = Array.from(element.attributes);
  return attributes.map((attr) => `${encodeURIComponent(attr.name)}=${encodeURIComponent(attr.value)}`).join("&");
}
function copyAttributes(element, target) {
  if (!element || !(element instanceof HTMLElement) || !target || !(target instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  Array.from(element.attributes).forEach((attr) => {
    setAttribute(target, { [attr.name]: attr.value });
  });
}
function findElementByAttribute(Element, attributeName) {
  return Array.from(Element.querySelectorAll(`[${attributeName}]`));
}
function toggleAttributes(element, attributes) {
  Object.keys(attributes).forEach((attr) => {
    if (attributes[attr]) {
      element.setAttribute(attr, "");
    } else {
      element.removeAttribute(attr);
    }
  });
}
function hasAnyAttributes(element) {
  return element.attributes.length > 0;
}
function removeAttributesByName(element, ...attributeNames) {
  attributeNames.forEach((attr) => {
    element.removeAttribute(attr);
  });
}
function getAttributesByPrefix(element, prefix) {
  const result = {};
  Array.from(element.attributes).forEach((attr) => {
    if (attr.name.startsWith(prefix)) {
      result[attr.name] = attr.value;
    }
  });
  return result;
}
function setAttributesFromQueryString(element, queryString, options = {}) {
  const {
    onError = (error) => console.error(error)
  } = options;
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof queryString !== "string" || !queryString.trim()) {
      throw new Error("Invalid queryString provided. It must be a non-empty string.");
    }
    const params = new URLSearchParams(queryString);
    try {
      setAttribute(element, params, options);
    } catch (attrError) {
      onError(attrError);
    }
  } catch (error) {
    onError(error);
  }
}
function compareAttributes(el1, el2, options = {}) {
  const diff = {};
  try {
    if (!(el1 instanceof HTMLElement) || !(el2 instanceof HTMLElement)) {
      throw new TypeError("Both el1 and el2 must be valid HTMLElements.");
    }
    const el1Attributes = el1.attributes;
    const el2Attributes = el2.attributes;
    const {
      onTrue = () => {
      },
      // Default no-op callback if not provided
      onFalse = () => {
      },
      // Default no-op callback if not provided
      ignoreAttributes = [],
      customCompare
    } = options;
    const shouldIgnore = (attrName) => ignoreAttributes.includes(attrName);
    Array.from(el1Attributes).forEach((attr) => {
      const el2Value = el2.getAttribute(attr.name);
      if (shouldIgnore(attr.name)) return;
      const isEqual = customCompare ? customCompare(attr.value, el2Value) : attr.value === el2Value;
      if (!isEqual) {
        diff[attr.name] = { el1Value: attr.value, el2Value };
        onFalse(attr.name, attr.value, el2Value);
      } else {
        onTrue(attr.name, attr.value, el2Value);
      }
    });
    Array.from(el2Attributes).forEach((attr) => {
      if (!el1.hasAttribute(attr.name) && !shouldIgnore(attr.name)) {
        diff[attr.name] = { el1Value: null, el2Value: attr.value };
        onFalse(attr.name, null, attr.value);
      }
    });
  } catch (error) {
    console.error(`Error comparing attributes: ${error.message}`);
  }
  return diff;
}
function removeAttributesByPrefix(element, prefixes, options) {
  const { onRemove, protectedAttr } = options;
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    const prefixList = Array.isArray(prefixes) ? prefixes : [prefixes];
    if (prefixList.length === 0 || prefixList.some((prefix) => typeof prefix !== "string" || !prefix.trim())) {
      throw new Error("Invalid prefixes provided. Prefixes must be non-empty strings.");
    }
    Array.from(element.attributes).forEach((attr) => {
      const attrName = attr.name;
      const shouldRemove = prefixList.some((prefix) => attrName.startsWith(prefix));
      if (shouldRemove) {
        if (typeof onRemove === "function") {
          onRemove(attrName);
        }
        const isRemovable = (attrName2) => {
          if (protectedAttr) {
            return !protectedAttr.includes(attrName2);
          }
        };
        if (isRemovable(attrName) === true) {
          element.removeAttribute(attrName);
        }
      }
    });
  } catch (error) {
    console.error(`Error while removing attributes by prefix: ${error.message}`);
  }
}
var Attribute = { ...attribute_exports };

// node_modules/@butility/dom/html.js
function create(name, options = {}, callback) {
  const element = document.createElement(name);
  if (options.class && Array.isArray(options.class)) {
    options.class.forEach((className) => {
      if (className) {
        element.classList.add(className);
      }
    });
  }
  if (options.attr) {
    for (const key in options.attr) {
      if (Object.hasOwnProperty.call(options.attr, key)) {
        element.setAttribute(key, options.attr[key]);
      }
    }
  }
  if (options.innerText) element.innerText = options.innerText;
  if (options.innerHTML) element.innerHTML = options.innerHTML;
  if (options.children && Array.isArray(options.children)) {
    options.children.forEach((child) => {
      if (child instanceof HTMLElement) {
        element.appendChild(child);
      }
    });
  }
  if (options.draggable) element.draggable = true;
  if (options.style) element.style.cssText = options.style;
  if (options.trackMutation) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        console.log("Mutation observed:", mutation);
      });
    });
    observer.observe(element, { attributes: true, childList: true, subtree: true });
  }
  if (callback && typeof callback === "function") callback(element);
  return element;
}
function setAttribute2(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(attribute)) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log) console.log(`Skipping attribute: ${finalAttributeName}`);
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(`Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`);
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log) console.log(`Set data attribute: data-${dataKey} = ${transformedValue}`);
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log) console.log(`Set attribute: ${finalAttributeName} = ${transformedValue}`);
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}
function setAttributeOrChildren(element, ...attributesOrChildren) {
  attributesOrChildren.forEach((item) => {
    if (typeof item === "object" && !(item instanceof HTMLElement)) {
      setAttribute2(element, item);
    } else if (item instanceof HTMLElement || typeof item === "string") {
      element.append(item);
    }
  });
}
function canvas(...attributesOrChildren) {
  const element = create("canvas");
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}

// src/core/camera.ts
function openCamera(options = {
  targetElementId: "camera"
}) {
  const { targetElementId } = options;
  return new Promise((resolve, reject) => {
    const videoElement = document.getElementById(
      targetElementId
    );
    if (!videoElement) {
      reject(new Error(`Element with ID ${targetElementId} not found.`));
      return;
    }
    navigator.mediaDevices.getUserMedia({ video: true, audio: true }).then((stream) => {
      videoElement.srcObject = stream;
      resolve(stream);
    }).catch((error) => {
      reject(error);
    });
  });
}
function capturePhoto(options = {
  targetElementId: "camera",
  fileType: "png"
}) {
  const { targetElementId, fileType } = options;
  return new Promise((resolve, reject) => {
    const videoElement = document.getElementById(
      targetElementId
    );
    if (!videoElement) {
      reject(new Error(`Element with ID ${targetElementId} not found.`));
      return;
    }
    navigator.mediaDevices.getUserMedia({ video: true }).then((mediaStream) => {
      setAttribute(videoElement, { srcObject: mediaStream });
      const canvas2 = canvas();
      const context = canvas2.getContext("2d");
      videoElement.addEventListener("loadedmetadata", () => {
        setAttribute(canvas2, {
          width: videoElement.videoWidth,
          height: videoElement.videoHeight
        });
        if (context) {
          context.drawImage(
            videoElement,
            0,
            0,
            canvas2.width,
            canvas2.height
          );
          canvas2.toBlob((blob) => {
            resolve(blob);
            mediaStream.getTracks().forEach((track) => track.stop());
          }, `image/${fileType}`);
        } else {
          reject(new Error("Failed to get canvas 2D context."));
        }
      });
      videoElement.onerror = () => {
        reject(new Error("Error capturing photo."));
      };
    }).catch((error) => {
      reject(new Error("Unable to access camera: " + error.message));
    });
  });
}
function recordVideo(options = {
  targetElementId: "camera",
  fileType: "webm",
  start: (startRecording) => startRecording(),
  stop: (mediaRecorder) => mediaRecorder.stop(),
  removeAudio: false,
  removeVideo: false
}) {
  const {
    targetElementId,
    duration,
    fileType,
    start,
    stop,
    removeAudio,
    removeVideo
  } = options;
  return new Promise((resolve, reject) => {
    const startRecording = () => {
      navigator.mediaDevices.getUserMedia({
        video: !removeVideo,
        audio: !removeAudio
      }).then((stream) => {
        const mediaStream = stream;
        const videoElement = document.getElementById(
          targetElementId
        );
        if (!videoElement) {
          reject(
            new Error(
              `Element with ID ${targetElementId} not found or camera not opened.`
            )
          );
          return;
        }
        setAttribute(videoElement, { srcObject: mediaStream, muted: true });
        const mediaRecorder = new MediaRecorder(mediaStream, {
          mimeType: `video/${fileType}`
        });
        const chunks = [];
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            chunks.push(event.data);
          }
        };
        mediaRecorder.onstop = () => {
          const videoBlob = new Blob(chunks, {
            type: `video/${fileType}`
          });
          resolve(videoBlob);
          mediaStream.getTracks().forEach((track) => track.stop());
        };
        mediaRecorder.start();
        if (duration) {
          setTimeout(() => {
            mediaRecorder.stop();
          }, duration);
        } else {
          stop(mediaRecorder);
        }
      }).catch((error) => {
        reject(error);
      });
    };
    start(startRecording);
  });
}

// src/modules/camera.ts
var Camera = {
  capturePhoto,
  openCamera,
  recordVideo
};
var camera_default = Camera;
export {
  capturePhoto,
  camera_default as default,
  openCamera,
  recordVideo
};
