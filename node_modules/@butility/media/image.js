// node_modules/@butility/dom/html.js
function create(name, options = {}, callback) {
  const element = document.createElement(name);
  if (options.class && Array.isArray(options.class)) {
    options.class.forEach((className) => {
      if (className) {
        element.classList.add(className);
      }
    });
  }
  if (options.attr) {
    for (const key in options.attr) {
      if (Object.hasOwnProperty.call(options.attr, key)) {
        element.setAttribute(key, options.attr[key]);
      }
    }
  }
  if (options.innerText) element.innerText = options.innerText;
  if (options.innerHTML) element.innerHTML = options.innerHTML;
  if (options.children && Array.isArray(options.children)) {
    options.children.forEach((child) => {
      if (child instanceof HTMLElement) {
        element.appendChild(child);
      }
    });
  }
  if (options.draggable) element.draggable = true;
  if (options.style) element.style.cssText = options.style;
  if (options.trackMutation) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        console.log("Mutation observed:", mutation);
      });
    });
    observer.observe(element, { attributes: true, childList: true, subtree: true });
  }
  if (callback && typeof callback === "function") callback(element);
  return element;
}
function setAttribute(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(attribute)) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log) console.log(`Skipping attribute: ${finalAttributeName}`);
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(`Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`);
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log) console.log(`Set data attribute: data-${dataKey} = ${transformedValue}`);
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log) console.log(`Set attribute: ${finalAttributeName} = ${transformedValue}`);
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}
function setAttributeOrChildren(element, ...attributesOrChildren) {
  attributesOrChildren.forEach((item) => {
    if (typeof item === "object" && !(item instanceof HTMLElement)) {
      setAttribute(element, item);
    } else if (item instanceof HTMLElement || typeof item === "string") {
      element.append(item);
    }
  });
}
function canvas(...attributesOrChildren) {
  const element = create("canvas");
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}

// node_modules/@butility/dom/attribute.js
var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var attribute_exports = {};
__export(attribute_exports, {
  attributesToQueryString: () => attributesToQueryString,
  compareAttributes: () => compareAttributes,
  copyAttributes: () => copyAttributes,
  findElementByAttribute: () => findElementByAttribute,
  getAllAttributes: () => getAllAttributes,
  getAttribute: () => getAttribute,
  getAttributesByPrefix: () => getAttributesByPrefix,
  hasAnyAttributes: () => hasAnyAttributes,
  hasAttribute: () => hasAttribute,
  removeAllAttributes: () => removeAllAttributes,
  removeAttribute: () => removeAttribute,
  removeAttributesByName: () => removeAttributesByName,
  removeAttributesByPrefix: () => removeAttributesByPrefix,
  setAttribute: () => setAttribute2,
  setAttributesFromQueryString: () => setAttributesFromQueryString,
  toggleAttribute: () => toggleAttribute,
  toggleAttributes: () => toggleAttributes
});
function setAttribute2(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(attribute)) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log) console.log(`Skipping attribute: ${finalAttributeName}`);
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(`Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`);
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log) console.log(`Set data attribute: data-${dataKey} = ${transformedValue}`);
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log) console.log(`Set attribute: ${finalAttributeName} = ${transformedValue}`);
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}
function removeAttribute(element, attributeName) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  if (/^data-/.test(attributeName)) {
    delete element.dataset[attributeName.slice(5)];
  } else if (element.hasAttribute(attributeName)) {
    element.removeAttribute(attributeName);
  } else {
    console.warn(`Attribute "${attributeName}" does not exist on`, element);
  }
}
function getAttribute(element, attributeName, options) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const result = {};
  let value;
  if (options?.dataPrefix && /^data-/.test(attributeName)) {
    value = element.dataset[attributeName.slice(5)] || null;
  } else {
    value = element.getAttribute(attributeName);
  }
  if (options?.transform) {
    value = options.transform(value);
  }
  result[attributeName] = value !== null ? value : options?.defaultValue || null;
  return result;
}
function getAllAttributes(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const attributes = {};
  Array.from(element.attributes).forEach((attr) => {
    attributes[attr.name] = attr.value;
  });
  Object.keys(element.dataset).forEach((dataKey) => {
    const dataValue = element.dataset[dataKey];
    if (dataValue !== void 0) {
      attributes[`data-${dataKey}`] = dataValue;
    }
  });
  return attributes;
}
function hasAttribute(element, attributeName) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  return /^data-/.test(attributeName) ? attributeName.slice(5) in element.dataset : element.hasAttribute(attributeName);
}
function toggleAttribute(element, attributeName, attributeValue) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  if (hasAttribute(element, attributeName)) {
    removeAttribute(element, attributeName);
  } else {
    setAttribute2(element, {
      [attributeName]: attributeValue
    });
  }
}
function removeAllAttributes(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  Array.from(element.attributes).forEach((attr) => {
    element.removeAttribute(attr.name);
  });
  Object.keys(element.dataset).forEach((dataKey) => {
    delete element.dataset[dataKey];
  });
}
function attributesToQueryString(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const attributes = Array.from(element.attributes);
  return attributes.map((attr) => `${encodeURIComponent(attr.name)}=${encodeURIComponent(attr.value)}`).join("&");
}
function copyAttributes(element, target) {
  if (!element || !(element instanceof HTMLElement) || !target || !(target instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  Array.from(element.attributes).forEach((attr) => {
    setAttribute2(target, { [attr.name]: attr.value });
  });
}
function findElementByAttribute(Element, attributeName) {
  return Array.from(Element.querySelectorAll(`[${attributeName}]`));
}
function toggleAttributes(element, attributes) {
  Object.keys(attributes).forEach((attr) => {
    if (attributes[attr]) {
      element.setAttribute(attr, "");
    } else {
      element.removeAttribute(attr);
    }
  });
}
function hasAnyAttributes(element) {
  return element.attributes.length > 0;
}
function removeAttributesByName(element, ...attributeNames) {
  attributeNames.forEach((attr) => {
    element.removeAttribute(attr);
  });
}
function getAttributesByPrefix(element, prefix) {
  const result = {};
  Array.from(element.attributes).forEach((attr) => {
    if (attr.name.startsWith(prefix)) {
      result[attr.name] = attr.value;
    }
  });
  return result;
}
function setAttributesFromQueryString(element, queryString, options = {}) {
  const {
    onError = (error) => console.error(error)
  } = options;
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof queryString !== "string" || !queryString.trim()) {
      throw new Error("Invalid queryString provided. It must be a non-empty string.");
    }
    const params = new URLSearchParams(queryString);
    try {
      setAttribute2(element, params, options);
    } catch (attrError) {
      onError(attrError);
    }
  } catch (error) {
    onError(error);
  }
}
function compareAttributes(el1, el2, options = {}) {
  const diff = {};
  try {
    if (!(el1 instanceof HTMLElement) || !(el2 instanceof HTMLElement)) {
      throw new TypeError("Both el1 and el2 must be valid HTMLElements.");
    }
    const el1Attributes = el1.attributes;
    const el2Attributes = el2.attributes;
    const {
      onTrue = () => {
      },
      // Default no-op callback if not provided
      onFalse = () => {
      },
      // Default no-op callback if not provided
      ignoreAttributes = [],
      customCompare
    } = options;
    const shouldIgnore = (attrName) => ignoreAttributes.includes(attrName);
    Array.from(el1Attributes).forEach((attr) => {
      const el2Value = el2.getAttribute(attr.name);
      if (shouldIgnore(attr.name)) return;
      const isEqual = customCompare ? customCompare(attr.value, el2Value) : attr.value === el2Value;
      if (!isEqual) {
        diff[attr.name] = { el1Value: attr.value, el2Value };
        onFalse(attr.name, attr.value, el2Value);
      } else {
        onTrue(attr.name, attr.value, el2Value);
      }
    });
    Array.from(el2Attributes).forEach((attr) => {
      if (!el1.hasAttribute(attr.name) && !shouldIgnore(attr.name)) {
        diff[attr.name] = { el1Value: null, el2Value: attr.value };
        onFalse(attr.name, null, attr.value);
      }
    });
  } catch (error) {
    console.error(`Error comparing attributes: ${error.message}`);
  }
  return diff;
}
function removeAttributesByPrefix(element, prefixes, options) {
  const { onRemove, protectedAttr } = options;
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    const prefixList = Array.isArray(prefixes) ? prefixes : [prefixes];
    if (prefixList.length === 0 || prefixList.some((prefix) => typeof prefix !== "string" || !prefix.trim())) {
      throw new Error("Invalid prefixes provided. Prefixes must be non-empty strings.");
    }
    Array.from(element.attributes).forEach((attr) => {
      const attrName = attr.name;
      const shouldRemove = prefixList.some((prefix) => attrName.startsWith(prefix));
      if (shouldRemove) {
        if (typeof onRemove === "function") {
          onRemove(attrName);
        }
        const isRemovable = (attrName2) => {
          if (protectedAttr) {
            return !protectedAttr.includes(attrName2);
          }
        };
        if (isRemovable(attrName) === true) {
          element.removeAttribute(attrName);
        }
      }
    });
  } catch (error) {
    console.error(`Error while removing attributes by prefix: ${error.message}`);
  }
}
var Attribute = { ...attribute_exports };

// src/core/image.ts
function resizeImage(file, maxWidth, maxHeight) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const canvas2 = canvas();
      const ctx = canvas2.getContext("2d");
      let width = img.width;
      let height = img.height;
      if (width > maxWidth) {
        height *= maxWidth / width;
        width = maxWidth;
      }
      if (height > maxHeight) {
        width *= maxHeight / height;
        height = maxHeight;
      }
      setAttribute2(canvas2, { width, height });
      if (ctx) ctx.drawImage(img, 0, 0, width, height);
      canvas2.toBlob((blob) => resolve(blob), file.type);
    };
    img.onerror = () => reject(new Error("Failed to load image"));
    setAttribute2(img, { src: URL.createObjectURL(file) });
  });
}
function rotateImage(file, degrees) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const canvas2 = canvas();
      const ctx = canvas2.getContext("2d");
      let width = img.width;
      let height = img.height;
      setAttribute2(canvas2, { width: height, height: width });
      if (ctx) {
        ctx.translate(canvas2.width / 2, canvas2.height / 2);
        ctx.rotate(degrees * (Math.PI / 180));
        ctx.drawImage(
          img,
          -width / 2,
          -height / 2,
          width,
          height
        );
      }
      canvas2.toBlob((blob) => resolve(blob), file.type);
    };
    img.onerror = () => reject(new Error("Failed to load image"));
    setAttribute2(img, { src: URL.createObjectURL(file) });
  });
}
function compressImage(file, quality) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const canvas2 = canvas();
      const ctx = canvas2.getContext("2d");
      let width = img.width;
      let height = img.height;
      setAttribute2(canvas2, { width, height });
      if (ctx) ctx.drawImage(img, 0, 0, width, height);
      canvas2.toBlob((blob) => resolve(blob), file.type, quality);
    };
    img.onerror = () => reject(new Error("Failed to load image"));
    setAttribute2(img, { src: URL.createObjectURL(file) });
  });
}
function cropImage(file, coordinates) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const canvas2 = canvas();
      const ctx = canvas2.getContext("2d");
      setAttribute2(canvas2, {
        width: coordinates.width,
        height: coordinates.height
      });
      if (ctx)
        ctx.drawImage(
          img,
          -coordinates.x,
          -coordinates.y,
          img.width,
          img.height
        );
      canvas2.toBlob((blob) => resolve(blob), file.type);
    };
    img.onerror = () => reject(new Error("Failed to load image"));
    setAttribute2(img, { src: URL.createObjectURL(file) });
  });
}
function flipImage(file, axis) {
  return new Promise((resolve, reject) => {
    const img = new Image();
    img.onload = () => {
      const canvas2 = canvas();
      const ctx = canvas2.getContext("2d");
      let width = img.width;
      let height = img.height;
      setAttribute2(canvas2, { width, height });
      if (axis === "horizontal" && ctx) {
        ctx.scale(-1, 1);
        ctx.drawImage(img, -width, 0, width, height);
      } else if (axis === "vertical" && ctx) {
        ctx.scale(1, -1);
        ctx.drawImage(img, 0, -height, width, height);
      } else {
        reject(
          new Error('Invalid axis. Use "horizontal" or "vertical".')
        );
        return;
      }
      canvas2.toBlob((blob) => resolve(blob), file.type);
    };
    img.onerror = () => reject(new Error("Failed to load image"));
    setAttribute2(img, { src: URL.createObjectURL(file) });
  });
}
function convertImageToBase64(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => {
      resolve(reader.result.split(",")[1]);
    };
    reader.onerror = () => {
      reject(new Error("Failed to read image as base64."));
    };
    reader.readAsDataURL(file);
  });
}
function preloadImagesWithCallback(imageUrls, callback) {
  const images = [];
  let loadedImages = 0;
  function imageLoaded() {
    loadedImages++;
    if (loadedImages === imageUrls.length) {
      callback(images);
    }
  }
  imageUrls.forEach((url, index) => {
    const img = new Image();
    img.onload = () => {
      images[index] = img;
      imageLoaded();
    };
    img.onerror = () => {
      console.error(`Failed to load image: ${url}`);
      imageLoaded();
    };
    setAttribute2(img, { src: url });
  });
}
function calculateAspectRatio(width, height) {
  return width / height;
}

// src/modules/image.ts
var Image2 = {
  calculateAspectRatio,
  compressImage,
  convertImageToBase64,
  cropImage,
  flipImage,
  preloadImagesWithCallback,
  resizeImage,
  rotateImage
};
var image_default = Image2;
export {
  calculateAspectRatio,
  compressImage,
  convertImageToBase64,
  cropImage,
  image_default as default,
  flipImage,
  preloadImagesWithCallback,
  resizeImage,
  rotateImage
};
