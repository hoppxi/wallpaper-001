// node_modules/@butility/dom/html.js
function create(name, options = {}, callback) {
  const element = document.createElement(name);
  if (options.class && Array.isArray(options.class)) {
    options.class.forEach((className) => {
      if (className) {
        element.classList.add(className);
      }
    });
  }
  if (options.attr) {
    for (const key in options.attr) {
      if (Object.hasOwnProperty.call(options.attr, key)) {
        element.setAttribute(key, options.attr[key]);
      }
    }
  }
  if (options.innerText) element.innerText = options.innerText;
  if (options.innerHTML) element.innerHTML = options.innerHTML;
  if (options.children && Array.isArray(options.children)) {
    options.children.forEach((child) => {
      if (child instanceof HTMLElement) {
        element.appendChild(child);
      }
    });
  }
  if (options.draggable) element.draggable = true;
  if (options.style) element.style.cssText = options.style;
  if (options.trackMutation) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        console.log("Mutation observed:", mutation);
      });
    });
    observer.observe(element, { attributes: true, childList: true, subtree: true });
  }
  if (callback && typeof callback === "function") callback(element);
  return element;
}
function setAttribute(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(attribute)) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log) console.log(`Skipping attribute: ${finalAttributeName}`);
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(`Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`);
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log) console.log(`Set data attribute: data-${dataKey} = ${transformedValue}`);
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log) console.log(`Set attribute: ${finalAttributeName} = ${transformedValue}`);
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}
function setAttributeOrChildren(element, ...attributesOrChildren) {
  attributesOrChildren.forEach((item) => {
    if (typeof item === "object" && !(item instanceof HTMLElement)) {
      setAttribute(element, item);
    } else if (item instanceof HTMLElement || typeof item === "string") {
      element.append(item);
    }
  });
}
function a(...attributesOrChildren) {
  const element = create("a");
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}
function body(...attributesOrChildren) {
  setAttributeOrChildren(document.body, ...attributesOrChildren);
  return document.body;
}

// src/core/blob.ts
function convertBase64ToBlob(base64, contentType, onProgress) {
  try {
    const byteCharacters = atob(base64);
    const byteNumbers = new Array(byteCharacters.length);
    for (let i = 0; i < byteCharacters.length; i++) {
      byteNumbers[i] = byteCharacters.charCodeAt(i);
      if (onProgress) onProgress(i / byteCharacters.length);
    }
    const byteArray = new Uint8Array(byteNumbers);
    return new Blob([byteArray], { type: contentType });
  } catch (error) {
    throw new Error(`Failed to convert base64 to Blob: ${error.message}`);
  }
}
async function convertBlobToBase64(blob, onProgress) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onprogress = (event) => {
      if (event.lengthComputable && onProgress) {
        onProgress(event.loaded / event.total);
      }
    };
    reader.onloadend = () => {
      if (reader.result) {
        const base64String = reader.result.split(",")[1];
        resolve(base64String);
      } else {
        reject(new Error("Reader result is empty"));
      }
    };
    reader.onerror = () => reject(new Error("Failed to convert Blob to base64"));
    reader.readAsDataURL(blob);
  });
}
function downloadBlob(blob, filename, fallbackContentType = "application/octet-stream") {
  const contentType = blob.type || fallbackContentType;
  const url = URL.createObjectURL(new Blob([blob], { type: contentType }));
  const link = a({ href: url, download: filename });
  body(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}
function textToBlob(text, encoding = "utf-8") {
  const encoder = new TextEncoder();
  const uint8Array = encoder.encode(text);
  return new Blob([uint8Array], { type: `text/plain;charset=${encoding}` });
}
function mergeBlobs(blobs, contentType = "application/octet-stream", bufferSize = 1024) {
  const blobBuffers = blobs.map((blob) => blob.slice(0, bufferSize));
  return new Blob(blobBuffers, { type: contentType });
}
async function encryptBlob(blob, key) {
  const arrayBuffer = await blob.arrayBuffer();
  const iv = window.crypto.getRandomValues(new Uint8Array(12));
  const encryptedData = await window.crypto.subtle.encrypt(
    { name: "AES-GCM", iv },
    key,
    arrayBuffer
  );
  return new Blob([iv, encryptedData], { type: blob.type });
}
async function decryptBlob(encryptedBlob, key) {
  const arrayBuffer = await encryptedBlob.arrayBuffer();
  const iv = arrayBuffer.slice(0, 12);
  const encryptedData = arrayBuffer.slice(12);
  const decryptedData = await window.crypto.subtle.decrypt(
    { name: "AES-GCM", iv: new Uint8Array(iv) },
    key,
    encryptedData
  );
  return new Blob([decryptedData], { type: encryptedBlob.type });
}
function chunkBlob(blob, chunkSize) {
  const chunks = [];
  let offset = 0;
  while (offset < blob.size) {
    const chunk = blob.slice(offset, offset + chunkSize);
    chunks.push(chunk);
    offset += chunkSize;
  }
  return chunks;
}
async function readBlobAsText(blob, encoding = "utf-8") {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(new Error("Failed to read Blob as text"));
    reader.readAsText(blob, encoding);
  });
}
function verifyBlob(blob, options = {}) {
  if (options.maxSize && blob.size > options.maxSize) {
    return false;
  }
  if (options.allowedTypes && !options.allowedTypes.includes(blob.type)) {
    return false;
  }
  return true;
}
async function blobToHex(blob) {
  const arrayBuffer = await blob.arrayBuffer();
  const byteArray = new Uint8Array(arrayBuffer);
  const hexString = Array.from(byteArray).map((byte) => byte.toString(16).padStart(2, "0")).join("");
  return hexString;
}

// src/modules/blob.ts
var Blob2 = {
  blobToHex,
  chunkBlob,
  convertBase64ToBlob,
  convertBlobToBase64,
  decryptBlob,
  downloadBlob,
  encryptBlob,
  mergeBlobs,
  readBlobAsText,
  textToBlob,
  verifyBlob
};
var blob_default = Blob2;
export {
  blobToHex,
  chunkBlob,
  convertBase64ToBlob,
  convertBlobToBase64,
  decryptBlob,
  blob_default as default,
  downloadBlob,
  encryptBlob,
  mergeBlobs,
  readBlobAsText,
  textToBlob,
  verifyBlob
};
