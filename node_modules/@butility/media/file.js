// node_modules/@butility/network/network.js
async function ajaxFetch(options) {
  const config = {
    method: options.method,
    headers: options.headers,
    body: options.method !== "GET" ? formatDataForFetch(options.data, options.headers) : void 0,
    signal: options.abortSignal
  };
  try {
    const response = await fetch(options.url, config);
    const responseBody = await handleFetchResponse(
      response,
      options.responseType
    );
    if (options.success) options.success(responseBody);
  } catch (error) {
    handleError(options, error);
  }
}
function ajaxXHR(options) {
  const xhr = new XMLHttpRequest();
  xhr.open(options.method, options.url, true);
  if (options.headers) {
    for (const [key, value] of Object.entries(options.headers)) {
      xhr.setRequestHeader(key, value);
    }
  }
  if (options.responseType) {
    xhr.responseType = options.responseType;
  }
  if (options.timeout) {
    xhr.timeout = options.timeout;
  }
  if (options.onProgress) {
    xhr.onprogress = (event) => {
      options.onProgress(event.loaded, event.total);
    };
  }
  xhr.onload = function() {
    if (xhr.status >= 200 && xhr.status < 300) {
      if (options.success) {
        const response = options.responseType === "json" ? xhr.response : xhr.responseText;
        options.success(response);
      }
    } else {
      handleError(
        options,
        `Request failed with status ${xhr.status}: ${xhr.statusText}`
      );
    }
  };
  xhr.onerror = function() {
    handleError(options, "Request failed due to network error.");
  };
  xhr.ontimeout = function() {
    handleError(options, `Request timed out after ${xhr.timeout}ms`);
  };
  retryRequest(xhr, options);
  const requestData = formatDataForXHR(options.data, options.headers);
  xhr.send(requestData);
}
async function handleFetchResponse(response, responseType) {
  if (!response.ok) {
    throw new Error(`HTTP error: ${response.status}`);
  }
  switch (responseType) {
    case "json":
      return await response.json();
    case "blob":
      return await response.blob();
    case "arraybuffer":
      return await response.arrayBuffer();
    default:
      return await response.text();
  }
}
function formatDataForFetch(data, headers) {
  if (data && typeof data === "object" && !(data instanceof FormData)) {
    if (headers && headers["Content-Type"] === "application/json") {
      return JSON.stringify(data);
    }
  }
  return data;
}
function handleError(options, error) {
  if (options.error) {
    options.error(error);
  } else {
    console.error(error);
  }
}
function retryRequest(xhr, options, attempt = 1) {
  xhr.onloadend = () => {
    if (xhr.status >= 400 && attempt <= (options.retries || 1)) {
      setTimeout(() => {
        console.warn(
          `Retrying request... (${attempt}/${options.retries})`
        );
        ajaxXHR({ ...options, retries: options.retries - 1 });
      }, options.retryDelay || 1e3);
    }
  };
}
function formatDataForXHR(data, headers) {
  if (data && typeof data === "object" && !(data instanceof FormData)) {
    if (headers && headers["Content-Type"] === "application/json") {
      return JSON.stringify(data);
    }
  }
  return data;
}
function ajax(options) {
  if (options.useFetch) {
    return ajaxFetch(options);
  } else {
    return ajaxXHR(options);
  }
}
function get(url, data = {}, options = {}) {
  const queryString = Object.entries(data).map(
    ([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`
  ).join("&");
  const fullUrl = queryString ? `${url}?${queryString}` : url;
  return ajax({
    method: "GET",
    url: fullUrl,
    ...options
  });
}
function post(url, data, options = {}) {
  return ajax({
    method: "POST",
    url,
    data,
    headers: { "Content-Type": "application/json" },
    ...options
  });
}
function put(url, data, options = {}) {
  return ajax({
    method: "PUT",
    url,
    data,
    headers: { "Content-Type": "application/json" },
    ...options
  });
}
function patch(url, data, options = {}) {
  return ajax({
    method: "PATCH",
    url,
    data,
    headers: { "Content-Type": "application/json" },
    ...options
  });
}
function deleteRequest(url, data = {}, options = {}) {
  const queryString = Object.entries(data).map(
    ([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`
  ).join("&");
  const fullUrl = queryString ? `${url}?${queryString}` : url;
  return ajax({
    method: "DELETE",
    url: fullUrl,
    ...options
  });
}
var Request = {
  ajax,
  get,
  patch,
  post,
  put,
  deleteRequest
};
var request_default = Request;

// node_modules/@butility/dom/html.js
function create(name, options = {}, callback) {
  const element = document.createElement(name);
  if (options.class && Array.isArray(options.class)) {
    options.class.forEach((className) => {
      if (className) {
        element.classList.add(className);
      }
    });
  }
  if (options.attr) {
    for (const key in options.attr) {
      if (Object.hasOwnProperty.call(options.attr, key)) {
        element.setAttribute(key, options.attr[key]);
      }
    }
  }
  if (options.innerText) element.innerText = options.innerText;
  if (options.innerHTML) element.innerHTML = options.innerHTML;
  if (options.children && Array.isArray(options.children)) {
    options.children.forEach((child) => {
      if (child instanceof HTMLElement) {
        element.appendChild(child);
      }
    });
  }
  if (options.draggable) element.draggable = true;
  if (options.style) element.style.cssText = options.style;
  if (options.trackMutation) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        console.log("Mutation observed:", mutation);
      });
    });
    observer.observe(element, { attributes: true, childList: true, subtree: true });
  }
  if (callback && typeof callback === "function") callback(element);
  return element;
}
function setAttribute(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(attribute)) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log) console.log(`Skipping attribute: ${finalAttributeName}`);
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(`Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`);
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log) console.log(`Set data attribute: data-${dataKey} = ${transformedValue}`);
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log) console.log(`Set attribute: ${finalAttributeName} = ${transformedValue}`);
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}
function setAttributeOrChildren(element, ...attributesOrChildren) {
  attributesOrChildren.forEach((item) => {
    if (typeof item === "object" && !(item instanceof HTMLElement)) {
      setAttribute(element, item);
    } else if (item instanceof HTMLElement || typeof item === "string") {
      element.append(item);
    }
  });
}
function a(...attributesOrChildren) {
  const element = create("a");
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}
function body(...attributesOrChildren) {
  setAttributeOrChildren(document.body, ...attributesOrChildren);
  return document.body;
}

// src/core/blob.ts
function downloadBlob(blob, filename, fallbackContentType = "application/octet-stream") {
  const contentType = blob.type || fallbackContentType;
  const url = URL.createObjectURL(new Blob([blob], { type: contentType }));
  const link = a({ href: url, download: filename });
  body(link);
  link.click();
  document.body.removeChild(link);
  URL.revokeObjectURL(url);
}

// src/core/file.ts
function validateFileType(file, allowedTypes, allowedExtensions) {
  const fileType = file.type;
  const fileName = file.name;
  const fileExtension = fileName.substring(fileName.lastIndexOf(".") + 1).toLowerCase();
  const mimeTypeValid = allowedTypes.some((typePattern) => {
    const regex = new RegExp(`^${typePattern.replace("*", ".*")}$`);
    return regex.test(fileType);
  });
  const extensionValid = allowedExtensions.includes(fileExtension);
  if (!mimeTypeValid || !extensionValid) {
    console.error(
      `File type or extension not allowed. Got type: ${fileType}, extension: ${fileExtension}`
    );
    return false;
  }
  return true;
}
function validateFileSize(file, maxSize) {
  return file.size <= maxSize;
}
function uploadFile(file, url) {
  return new Promise((resolve, reject) => {
    const formData = new FormData();
    formData.append("file", file);
    request_default.post(url, formData, {
      useFetch: true,
      success: (response) => {
        if (response) {
          resolve(response);
        } else {
          reject(new Error("File upload failed"));
        }
      }
    });
  });
}
async function downloadFile(fileUrl, fileName, fileType) {
  return new Promise((resolve, reject) => {
    request_default.get(fileUrl, {}, {
      useFetch: true,
      success: (response) => {
        if (response) {
          const blob = new Blob(
            [response],
            fileType ? { type: fileType } : {}
          );
          downloadBlob(blob, fileName);
          resolve(response);
        } else {
          reject(new Error(`Failed to download file.`));
        }
      }
    });
  });
}
async function unzip(zipBlob) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = async (event) => {
      const arrayBuffer = event.target?.result;
      const extractedFiles = [];
      try {
        const view = new DataView(arrayBuffer);
        let offset = 0;
        while (offset < view.byteLength) {
          const signature = view.getUint32(offset, true);
          if (signature !== 67324752) {
            throw new Error("Invalid ZIP file format.");
          }
          const fileNameLength = view.getUint16(offset + 26, true);
          const extraFieldLength = view.getUint16(offset + 28, true);
          const fileNameStart = offset + 30;
          const fileName = new TextDecoder().decode(
            new Uint8Array(
              arrayBuffer,
              fileNameStart,
              fileNameLength
            )
          );
          const compressedSize = view.getUint32(offset + 18, true);
          const fileDataStart = fileNameStart + fileNameLength + extraFieldLength;
          const fileDataEnd = fileDataStart + compressedSize;
          const compressionMethod = view.getUint16(offset + 8, true);
          let fileContent;
          if (compressionMethod === 0) {
            fileContent = arrayBuffer.slice(
              fileDataStart,
              fileDataEnd
            );
          } else if (compressionMethod === 8) {
            const compressedData = arrayBuffer.slice(
              fileDataStart,
              fileDataEnd
            );
            fileContent = await decompressDEFLATE(compressedData);
          } else {
            throw new Error(
              `Unsupported compression method: ${compressionMethod}`
            );
          }
          extractedFiles.push(new File([fileContent], fileName));
          offset = fileDataEnd;
        }
        resolve(extractedFiles);
      } catch (error) {
        reject(
          new Error(
            `Failed to parse ZIP file: ${error.message}`
          )
        );
      }
    };
    reader.onerror = () => {
      reject(new Error("Error reading ZIP Blob."));
    };
    reader.readAsArrayBuffer(zipBlob);
  });
}
async function decompressDEFLATE(compressedData) {
  const decompressedChunks = [];
  if (typeof DecompressionStream === "undefined") {
    throw new Error(
      "DecompressionStream is not supported in this browser."
    );
  }
  const decompressionStream = new DecompressionStream("deflate");
  const writer = decompressionStream.writable.getWriter();
  const reader = decompressionStream.readable.getReader();
  const stream = new ReadableStream({
    start(controller) {
      controller.enqueue(new Uint8Array(compressedData));
      controller.close();
    }
  });
  await stream.pipeTo(decompressionStream.writable);
  while (true) {
    const { done, value } = await reader.read();
    if (done) break;
    if (value) decompressedChunks.push(value);
  }
  const totalLength = decompressedChunks.reduce(
    (sum, chunk) => sum + chunk.length,
    0
  );
  const decompressedArray = new Uint8Array(totalLength);
  let offset = 0;
  for (const chunk of decompressedChunks) {
    decompressedArray.set(chunk, offset);
    offset += chunk.length;
  }
  return decompressedArray.buffer;
}
async function zip(files, zipFileName) {
  const zipData = [];
  for (const file of files) {
    const content = new Uint8Array(await file.arrayBuffer());
    zipData.push({
      name: file.name,
      content,
      contentLength: content.length
    });
  }
  const centralDirectory = [];
  let currentOffset = 0;
  zipData.forEach((file) => {
    centralDirectory.push({
      name: file.name,
      offset: currentOffset,
      contentLength: file.contentLength
    });
    currentOffset += file.contentLength;
  });
  const zipArray = [];
  zipData.forEach((file) => {
    const header = new Uint8Array([
      80,
      75,
      3,
      4,
      // local file header signature
      10,
      0,
      // version needed to extract
      0,
      0,
      // general purpose bit flag
      0,
      0,
      // compression method (0 = store)
      0,
      0,
      0,
      0,
      // file modification time/date
      0,
      0,
      0,
      0,
      file.contentLength & 255,
      file.contentLength >> 8 & 255,
      // compressed size
      file.contentLength & 255,
      file.contentLength >> 8 & 255,
      // uncompressed size
      file.name.length & 255,
      file.name.length >> 8 & 255,
      // file name length
      0,
      0
      // extra field length
    ]);
    const nameEncoded = new TextEncoder().encode(file.name);
    const localFileHeader = new Uint8Array(
      header.length + nameEncoded.length + file.content.length
    );
    localFileHeader.set(header);
    localFileHeader.set(nameEncoded, header.length);
    localFileHeader.set(file.content, header.length + nameEncoded.length);
    zipArray.push(localFileHeader);
  });
  const centralDirectoryArray = [];
  centralDirectory.forEach((file) => {
    const header = new Uint8Array([
      80,
      75,
      1,
      2,
      // central file header signature
      10,
      0,
      // version made by
      10,
      0,
      // version needed to extract
      0,
      0,
      // general purpose bit flag
      0,
      0,
      // compression method
      0,
      0,
      0,
      0,
      // file modification time/date
      0,
      0,
      0,
      0,
      // CRC-32
      file.contentLength & 255,
      file.contentLength >> 8 & 255,
      // compressed size
      file.contentLength & 255,
      file.contentLength >> 8 & 255,
      // uncompressed size
      file.name.length & 255,
      file.name.length >> 8 & 255,
      // file name length
      0,
      0,
      // extra field length
      0,
      0,
      // file comment length
      0,
      0,
      // disk number start
      0,
      0,
      // internal file attributes
      0,
      0,
      0,
      0,
      // external file attributes
      file.offset & 255,
      file.offset >> 8 & 255,
      file.offset >> 16 & 255,
      file.offset >> 24 & 255
      // relative offset of local header
    ]);
    const nameEncoded = new TextEncoder().encode(file.name);
    const centralFileHeader = new Uint8Array(
      header.length + nameEncoded.length
    );
    centralFileHeader.set(header);
    centralFileHeader.set(nameEncoded, header.length);
    centralDirectoryArray.push(centralFileHeader);
  });
  const endOfCentralDirectory = new Uint8Array([
    80,
    75,
    5,
    6,
    // end of central directory signature
    0,
    0,
    // number of this disk
    0,
    0,
    // disk where central directory starts
    centralDirectory.length & 255,
    centralDirectory.length >> 8 & 255,
    // total number of entries on this disk
    centralDirectory.length & 255,
    centralDirectory.length >> 8 & 255,
    // total number of entries overall
    centralDirectoryArray.reduce((acc, entry) => acc + entry.length, 0) & 255,
    // size of central directory
    currentOffset & 255,
    currentOffset >> 8 & 255,
    currentOffset >> 16 & 255,
    currentOffset >> 24 & 255,
    // offset of start of central directory
    0,
    0
    // zip file comment length
  ]);
  const totalLength = zipArray.reduce((acc, entry) => acc + entry.length, 0) + centralDirectoryArray.reduce((acc, entry) => acc + entry.length, 0) + endOfCentralDirectory.length;
  const zipFile = new Uint8Array(totalLength);
  currentOffset = 0;
  zipArray.forEach((entry) => {
    zipFile.set(entry, currentOffset);
    currentOffset += entry.length;
  });
  centralDirectoryArray.forEach((entry) => {
    zipFile.set(entry, currentOffset);
    currentOffset += entry.length;
  });
  zipFile.set(endOfCentralDirectory, currentOffset);
  const zipBlob = new Blob([zipFile], { type: "application/zip" });
  downloadBlob(zipBlob, zipFileName);
  return zipBlob;
}

// src/modules/file.ts
var File2 = {
  decompressDEFLATE,
  downloadFile,
  unzip,
  uploadFile,
  validateFileSize,
  validateFileType,
  zip
};
var file_default = File2;
export {
  decompressDEFLATE,
  file_default as default,
  downloadFile,
  unzip,
  uploadFile,
  validateFileSize,
  validateFileType,
  zip
};
