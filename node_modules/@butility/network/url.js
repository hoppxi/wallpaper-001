// src/core/url.ts
function parseQueryStringParameters(queryString, decode = true) {
  const params = {};
  if (!queryString || typeof queryString !== "string") {
    return params;
  }
  queryString = queryString.startsWith("?") ? queryString.slice(1) : queryString;
  const pairs = queryString.split("&");
  for (const pair of pairs) {
    const [key, value] = pair.split("=");
    const decodedKey = decode ? decodeURIComponent(key) : key;
    const decodedValue = value ? decode ? decodeURIComponent(value) : value : "";
    if (params.hasOwnProperty(decodedKey)) {
      if (Array.isArray(params[decodedKey])) {
        params[decodedKey].push(decodedValue);
      } else {
        params[decodedKey] = [params[decodedKey], decodedValue];
      }
    } else {
      params[decodedKey] = decodedValue;
    }
  }
  return params;
}
function replaceQueryStringParameter(url, key, value, encode = true) {
  if (!url || typeof url !== "string") {
    return url;
  }
  const [baseUrl, queryString] = url.split("?");
  const params = {};
  if (queryString) {
    const pairs = queryString.split("&");
    for (const pair of pairs) {
      const [existingKey, existingValue] = pair.split("=");
      const decodedKey = decodeURIComponent(existingKey);
      const decodedValue = existingValue ? decodeURIComponent(existingValue) : "";
      params[decodedKey] = decodedValue;
    }
  }
  const keyToUse = encode ? encodeURIComponent(key) : key;
  const valueToUse = encode ? encodeURIComponent(value) : value;
  params[keyToUse] = valueToUse;
  const newQueryString = Object.entries(params).map(([k, v]) => `${k}=${v}`).join("&");
  return newQueryString ? `${baseUrl}?${newQueryString}` : baseUrl;
}
function removeQueryStringParameter(url, key) {
  if (!url || typeof url !== "string") {
    return url;
  }
  const [baseUrl, queryString] = url.split("?");
  const params = {};
  if (queryString) {
    const pairs = queryString.split("&");
    for (const pair of pairs) {
      const [existingKey, existingValue] = pair.split("=");
      const decodedKey = decodeURIComponent(existingKey);
      const decodedValue = existingValue ? decodeURIComponent(existingValue) : "";
      params[decodedKey] = decodedValue;
    }
    delete params[key];
  }
  const newQueryString = Object.entries(params).map(([k, v]) => `${k}=${v}`).join("&");
  return newQueryString ? `${baseUrl}?${newQueryString}` : baseUrl;
}
function mergeURL(baseURL, relativeURL) {
  const base = new URL(baseURL);
  const relative = new URL(relativeURL, base);
  relative.search = relative.search || base.search;
  relative.hash = relative.hash || base.hash;
  return relative.href;
}
function normalizeURL(url) {
  try {
    const normalized = new URL(url);
    normalized.hash = normalized.hash.replace(/#$/, "");
    return normalized.href;
  } catch (error) {
    console.error("Invalid URL provided for normalization:", error);
    return url;
  }
}
function extractFragment(url) {
  try {
    const fragment = new URL(url).hash.substring(1);
    return decodeURIComponent(fragment);
  } catch {
    console.error("Failed to extract or decode fragment from URL:", url);
    return "";
  }
}
function constructURL(base, path = "", queryParams = {}) {
  try {
    const url = new URL(base);
    if (path) url.pathname = path;
    Object.entries(queryParams).forEach(([key, value]) => {
      url.searchParams.set(key, value);
    });
    return url.href;
  } catch (error) {
    console.error("Error constructing URL:", error);
    return "";
  }
}

// src/modules/url.ts
var URL2 = {
  constructURL,
  parseQueryStringParameters,
  removeQueryStringParameter,
  replaceQueryStringParameter,
  extractFragment,
  mergeURL,
  normalizeURL
};
var url_default = URL2;
export {
  constructURL,
  url_default as default,
  extractFragment,
  mergeURL,
  normalizeURL,
  parseQueryStringParameters,
  removeQueryStringParameter,
  replaceQueryStringParameter
};
