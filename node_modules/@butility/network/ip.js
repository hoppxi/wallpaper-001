// src/utils/ajax.ts
async function ajaxFetch(options) {
  const config = {
    method: options.method,
    headers: options.headers,
    body: options.method !== "GET" ? formatDataForFetch(options.data, options.headers) : void 0,
    signal: options.abortSignal
  };
  try {
    const response = await fetch(options.url, config);
    const responseBody = await handleFetchResponse(
      response,
      options.responseType
    );
    if (options.success) options.success(responseBody);
  } catch (error) {
    handleError(options, error);
  }
}
function ajaxXHR(options) {
  const xhr = new XMLHttpRequest();
  xhr.open(options.method, options.url, true);
  if (options.headers) {
    for (const [key, value] of Object.entries(options.headers)) {
      xhr.setRequestHeader(key, value);
    }
  }
  if (options.responseType) {
    xhr.responseType = options.responseType;
  }
  if (options.timeout) {
    xhr.timeout = options.timeout;
  }
  if (options.onProgress) {
    xhr.onprogress = (event) => {
      options.onProgress(event.loaded, event.total);
    };
  }
  xhr.onload = function() {
    if (xhr.status >= 200 && xhr.status < 300) {
      if (options.success) {
        const response = options.responseType === "json" ? xhr.response : xhr.responseText;
        options.success(response);
      }
    } else {
      handleError(
        options,
        `Request failed with status ${xhr.status}: ${xhr.statusText}`
      );
    }
  };
  xhr.onerror = function() {
    handleError(options, "Request failed due to network error.");
  };
  xhr.ontimeout = function() {
    handleError(options, `Request timed out after ${xhr.timeout}ms`);
  };
  retryRequest(xhr, options);
  const requestData = formatDataForXHR(options.data, options.headers);
  xhr.send(requestData);
}
async function handleFetchResponse(response, responseType) {
  if (!response.ok) {
    throw new Error(`HTTP error: ${response.status}`);
  }
  switch (responseType) {
    case "json":
      return await response.json();
    case "blob":
      return await response.blob();
    case "arraybuffer":
      return await response.arrayBuffer();
    default:
      return await response.text();
  }
}
function formatDataForFetch(data, headers) {
  if (data && typeof data === "object" && !(data instanceof FormData)) {
    if (headers && headers["Content-Type"] === "application/json") {
      return JSON.stringify(data);
    }
  }
  return data;
}
function handleError(options, error) {
  if (options.error) {
    options.error(error);
  } else {
    console.error(error);
  }
}
function retryRequest(xhr, options, attempt = 1) {
  xhr.onloadend = () => {
    if (xhr.status >= 400 && attempt <= (options.retries || 1)) {
      setTimeout(() => {
        console.warn(
          `Retrying request... (${attempt}/${options.retries})`
        );
        ajaxXHR({ ...options, retries: options.retries - 1 });
      }, options.retryDelay || 1e3);
    }
  };
}
function formatDataForXHR(data, headers) {
  if (data && typeof data === "object" && !(data instanceof FormData)) {
    if (headers && headers["Content-Type"] === "application/json") {
      return JSON.stringify(data);
    }
  }
  return data;
}

// src/core/request.ts
function ajax(options) {
  if (options.useFetch) {
    return ajaxFetch(options);
  } else {
    return ajaxXHR(options);
  }
}
function get(url, data = {}, options = {}) {
  const queryString = Object.entries(data).map(
    ([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`
  ).join("&");
  const fullUrl = queryString ? `${url}?${queryString}` : url;
  return ajax({
    method: "GET",
    url: fullUrl,
    ...options
  });
}

// src/core/ip.ts
function isValidIPv4(ip) {
  const ipv4Regex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  return ipv4Regex.test(ip);
}
function isValidIPv6(ip) {
  const ipv6Regex = /^(?:^([0-9a-fA-F]{1,4}:){7}([0-9a-fA-F]{1,4}|:)$)|(^([0-9a-fA-F]{1,4}:){1,7}:$)|(^([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}$)|(^([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}$)|(^([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}$)|(^([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}$)|(^([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}$)|(^([0-9a-fA-F]{1,4}:){1}(:[0-9a-fA-F]{1,4}){1,6}$)|(^:((:[0-9a-fA-F]{1,4}){1,7}|:)$)|(^([0-9a-fA-F]{1,4}:){1,7}:)$/;
  return ipv6Regex.test(ip);
}
function convertIPv4ToIPv6(ip) {
  if (!isValidIPv4(ip)) {
    console.error("Invalid IPv4 address provided.");
    return null;
  }
  const segments = ip.split(".").map(Number);
  const hexSegments = segments.map(
    (segment) => segment.toString(16).padStart(2, "0")
  );
  const ipv6 = `::ffff:${hexSegments.join(":")}`;
  return ipv6;
}
function convertIPv6ToIPv4(ip) {
  if (!isValidIPv6(ip)) {
    console.error("Invalid IPv6 address provided.");
    return null;
  }
  const ipv4Regex = /::ffff:([\da-f]{2}):([\da-f]{2}):([\da-f]{2}):([\da-f]{2})/i;
  const match = ip.match(ipv4Regex);
  if (!match) {
    console.error("Not a valid IPv6-mapped IPv4 address.");
    return null;
  }
  const ipv4Parts = match.slice(1, 5).map((hex) => parseInt(hex, 16));
  const ipv4 = ipv4Parts.join(".");
  return ipv4;
}
function normalizeIPv6(ip) {
  if (!isValidIPv6(ip)) return null;
  try {
    const segments = ip.split(":");
    let fullSegments = [];
    segments.forEach((segment) => {
      if (segment === "") {
        const fillLength = 8 - segments.filter((s) => s !== "").length;
        fullSegments.push(...Array(fillLength).fill("0000"));
      } else {
        fullSegments.push(segment.padStart(4, "0"));
      }
    });
    return fullSegments.join(":");
  } catch (e) {
    console.error("Error normalizing IPv6:", e);
    return null;
  }
}
function getIPVersion(ip) {
  if (isValidIPv4(ip)) return 4;
  if (isValidIPv6(ip)) return 6;
  return null;
}
function isPrivateIP(ip) {
  if (!isValidIPv4(ip)) return false;
  const privateRanges = [
    /^10\./,
    // 10.0.0.0 - 10.255.255.255
    /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
    // 172.16.0.0 - 172.31.255.255
    /^192\.168\./
    // 192.168.0.0 - 192.168.255.255
  ];
  return privateRanges.some((range) => range.test(ip));
}
function generateRandomIPv4() {
  return Array(4).fill(0).map(() => Math.floor(Math.random() * 256)).join(".");
}
function generateRandomIPv6() {
  const getRandomHex = () => Math.floor(Math.random() * 65536).toString(16);
  const segments = Array.from({ length: 8 }, getRandomHex);
  return segments.join(":");
}
function isValidSubnetMask(mask) {
  const validMasks = [
    "255.255.255.255",
    "255.255.255.254",
    "255.255.255.252",
    "255.255.255.248",
    "255.255.255.240",
    "255.255.255.224",
    "255.255.255.192",
    "255.255.255.128",
    "255.255.255.0",
    "255.255.254.0",
    "255.255.252.0",
    "255.255.248.0",
    "255.255.240.0",
    "255.255.224.0",
    "255.255.192.0",
    "255.255.128.0",
    "255.255.0.0",
    "255.254.0.0",
    "255.252.0.0",
    "255.248.0.0",
    "255.240.0.0",
    "255.224.0.0",
    "255.192.0.0",
    "255.128.0.0",
    "255.0.0.0"
  ];
  return validMasks.includes(mask);
}
function extractFromCIDR(cidr) {
  const cidrRegex = /^([\d\.]+)\/(\d{1,2})$/;
  const match = cidr.match(cidrRegex);
  if (!match || !isValidIPv4(match[1]) || parseInt(match[2]) > 32)
    return null;
  const ip = match[1];
  const prefixLength = parseInt(match[2]);
  const maskBinary = "1".repeat(prefixLength).padEnd(32, "0");
  const mask = maskBinary.match(/.{8}/g)?.map((bin) => parseInt(bin, 2)).join(".") || "";
  return { ip, mask };
}
function calculateNetworkAddress(ip, mask) {
  if (!isValidIPv4(ip) || !isValidSubnetMask(mask)) return null;
  const ipSegments = ip.split(".").map(Number);
  const maskSegments = mask.split(".").map(Number);
  const networkAddress = ipSegments.map(
    (segment, i) => segment & maskSegments[i]
  );
  return networkAddress.join(".");
}
function areIPsInSameNetwork(ip1, ip2, mask) {
  const network1 = calculateNetworkAddress(ip1, mask);
  const network2 = calculateNetworkAddress(ip2, mask);
  return network1 === network2;
}
function getLocationByIP(ip, callback) {
  const apiUrl = `https://ipinfo.io/${ip}/json`;
  get(
    apiUrl,
    {},
    {
      responseType: "json",
      useFetch: true,
      error: (error) => {
        console.error("Error fetching geolocation information:", error);
        callback(null);
      },
      success: (response) => {
        const data = response;
        const location = {
          latitude: parseFloat(data.loc.split(",")[0]),
          longitude: parseFloat(data.loc.split(",")[1])
        };
        callback(location);
      }
    }
  );
}
function getUserIPAddress(callback) {
  const apiUrl = "https://api.ipify.org?format=json";
  get(
    apiUrl,
    {},
    {
      responseType: "json",
      useFetch: true,
      error: (error) => {
        console.error("Error fetching ip information:", error);
        callback(null);
      },
      success: (response) => {
        const data = response;
        const ip = data.ip;
        if (isValidIPv4(ip)) {
          callback(ip);
        }
      }
    }
  );
}

// src/modules/ip.ts
var IP = {
  isPrivateIP,
  isValidIPv4,
  isValidIPv6,
  isValidSubnetMask,
  calculateNetworkAddress,
  convertIPv4ToIPv6,
  convertIPv6ToIPv4,
  generateRandomIPv4,
  generateRandomIPv6,
  getIPVersion,
  getLocationByIP,
  getUserIPAddress,
  extractFromCIDR,
  areIPsInSameNetwork,
  normalizeIPv6
};
var ip_default = IP;
export {
  areIPsInSameNetwork,
  calculateNetworkAddress,
  convertIPv4ToIPv6,
  convertIPv6ToIPv4,
  ip_default as default,
  extractFromCIDR,
  generateRandomIPv4,
  generateRandomIPv6,
  getIPVersion,
  getLocationByIP,
  getUserIPAddress,
  isPrivateIP,
  isValidIPv4,
  isValidIPv6,
  isValidSubnetMask,
  normalizeIPv6
};
