// src/utils/sw.ts
var retryFailedRequests = async (url, retryDelay = 5, maxRetry = 3) => {
  let retryCount = 0;
  while (retryCount < maxRetry) {
    try {
      await fetch(url);
      console.log("Request successful");
      return;
    } catch (error) {
      retryCount++;
      console.warn(
        `Retrying request (${retryCount}/${maxRetry}) after ${retryDelay} seconds...`
      );
      await delay(retryDelay * 1e3);
    }
  }
  console.error("Failed to complete request after retries");
};
var delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// src/core/service-worker.ts
async function registerServiceWorker(swPath, options) {
  if ("serviceWorker" in navigator) {
    try {
      const registration = await navigator.serviceWorker.register(
        swPath,
        {
          scope: options?.scope,
          updateViaCache: options?.updateViaCache || "all"
        }
      );
      if (options?.onUpdateFound) {
        registration.onupdatefound = () => {
          const newWorker = registration.installing;
          const oldVersion = registration.active?.scriptURL || "none";
          if (newWorker) {
            newWorker.onstatechange = () => {
              if (newWorker.state === "installed" && navigator.serviceWorker.controller) {
                options.onUpdateFound(
                  oldVersion,
                  newWorker.scriptURL
                );
              }
            };
          }
        };
      }
      return registration;
    } catch (error) {
      console.error("Service Worker registration failed:", error);
    }
  }
  return void 0;
}
async function handleCachingStrategy(request, options) {
  const cache = await caches.open(options.cacheName);
  if (options.cacheFirst) {
    const cachedResponse = await cache.match(request);
    return cachedResponse || fetch(request).then(async (networkResponse) => {
      await cache.put(request, networkResponse.clone());
      return networkResponse;
    });
  } else {
    const fetchPromise = fetch(request).then(async (networkResponse) => {
      await cache.put(request, networkResponse.clone());
      return networkResponse;
    });
    if (options.networkTimeoutSeconds) {
      const timeoutPromise = new Promise((resolve, reject) => {
        setTimeout(
          async () => {
            const cachedResponse = await cache.match(request);
            cachedResponse ? resolve(cachedResponse) : reject("Request timed out");
          },
          options.networkTimeoutSeconds * 1e3
        );
      });
      return Promise.race([fetchPromise, timeoutPromise]);
    }
    return fetchPromise.catch(async () => {
      const cachedResponse = await cache.match(request);
      if (cachedResponse) return cachedResponse;
      throw new Error("Network and cache failed");
    });
  }
}
async function handleBackgroundSync(url, options) {
  if ("serviceWorker" in navigator && "SyncManager" in window) {
    try {
      const registration = await navigator.serviceWorker.ready;
      const syncRegistration = registration;
      if (syncRegistration.sync) {
        await syncRegistration.sync.register(options.tag);
        console.log(
          `Background sync registered with tag: ${options.tag}`
        );
      } else {
        console.warn("SyncManager is not supported in this browser.");
      }
      self.addEventListener("sync", (event) => {
        if (event.tag === options.tag) {
          event.waitUntil(
            retryFailedRequests(
              url,
              options.retryDelay,
              options.maxRetry
            )
          );
        }
      });
    } catch (err) {
      console.error("Background sync registration failed:", err);
    }
  } else {
    console.warn("Background sync is not supported in this browser.");
  }
}
function showPushNotification(registration, options) {
  const notificationOptions = {
    body: options.body,
    icon: options.icon ?? "/images/default-icon.png"
    // Use nullish coalescing for a safer default
  };
  registration.showNotification(options.title, notificationOptions);
  if (options.onNotificationClick) {
    const clickHandler = (event) => {
      event.notification.close();
      options.onNotificationClick(event);
    };
    self.removeEventListener("notificationclick", clickHandler);
    self.addEventListener("notificationclick", clickHandler);
  }
}
function sendMessageToSW(message) {
  if (navigator.serviceWorker.controller) {
    return new Promise((resolve, reject) => {
      const messageChannel = new MessageChannel();
      messageChannel.port1.onmessage = (event) => {
        if (event.data && event.data.error) {
          reject(event.data.error);
        } else {
          resolve(event.data);
        }
      };
      navigator.serviceWorker.controller.postMessage(message, [
        messageChannel.port2
      ]);
    });
  } else {
    return Promise.reject("No Service Worker controller found");
  }
}

// src/modules/sw.ts
var SW = {
  handleBackgroundSync,
  handleCachingStrategy,
  showPushNotification,
  sendMessageToSW,
  registerServiceWorker
};
var sw_default = SW;
export {
  sw_default as default,
  handleBackgroundSync,
  handleCachingStrategy,
  registerServiceWorker,
  sendMessageToSW,
  showPushNotification
};
