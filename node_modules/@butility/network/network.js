// src/utils/ajax.ts
async function ajaxFetch(options) {
  const config = {
    method: options.method,
    headers: options.headers,
    body: options.method !== "GET" ? formatDataForFetch(options.data, options.headers) : void 0,
    signal: options.abortSignal
  };
  try {
    const response = await fetch(options.url, config);
    const responseBody = await handleFetchResponse(
      response,
      options.responseType
    );
    if (options.success) options.success(responseBody);
  } catch (error) {
    handleError(options, error);
  }
}
function ajaxXHR(options) {
  const xhr = new XMLHttpRequest();
  xhr.open(options.method, options.url, true);
  if (options.headers) {
    for (const [key, value] of Object.entries(options.headers)) {
      xhr.setRequestHeader(key, value);
    }
  }
  if (options.responseType) {
    xhr.responseType = options.responseType;
  }
  if (options.timeout) {
    xhr.timeout = options.timeout;
  }
  if (options.onProgress) {
    xhr.onprogress = (event) => {
      options.onProgress(event.loaded, event.total);
    };
  }
  xhr.onload = function() {
    if (xhr.status >= 200 && xhr.status < 300) {
      if (options.success) {
        const response = options.responseType === "json" ? xhr.response : xhr.responseText;
        options.success(response);
      }
    } else {
      handleError(
        options,
        `Request failed with status ${xhr.status}: ${xhr.statusText}`
      );
    }
  };
  xhr.onerror = function() {
    handleError(options, "Request failed due to network error.");
  };
  xhr.ontimeout = function() {
    handleError(options, `Request timed out after ${xhr.timeout}ms`);
  };
  retryRequest(xhr, options);
  const requestData = formatDataForXHR(options.data, options.headers);
  xhr.send(requestData);
}
async function handleFetchResponse(response, responseType) {
  if (!response.ok) {
    throw new Error(`HTTP error: ${response.status}`);
  }
  switch (responseType) {
    case "json":
      return await response.json();
    case "blob":
      return await response.blob();
    case "arraybuffer":
      return await response.arrayBuffer();
    default:
      return await response.text();
  }
}
function formatDataForFetch(data, headers) {
  if (data && typeof data === "object" && !(data instanceof FormData)) {
    if (headers && headers["Content-Type"] === "application/json") {
      return JSON.stringify(data);
    }
  }
  return data;
}
function handleError(options, error) {
  if (options.error) {
    options.error(error);
  } else {
    console.error(error);
  }
}
function retryRequest(xhr, options, attempt = 1) {
  xhr.onloadend = () => {
    if (xhr.status >= 400 && attempt <= (options.retries || 1)) {
      setTimeout(() => {
        console.warn(
          `Retrying request... (${attempt}/${options.retries})`
        );
        ajaxXHR({ ...options, retries: options.retries - 1 });
      }, options.retryDelay || 1e3);
    }
  };
}
function formatDataForXHR(data, headers) {
  if (data && typeof data === "object" && !(data instanceof FormData)) {
    if (headers && headers["Content-Type"] === "application/json") {
      return JSON.stringify(data);
    }
  }
  return data;
}

// src/core/request.ts
function ajax(options) {
  if (options.useFetch) {
    return ajaxFetch(options);
  } else {
    return ajaxXHR(options);
  }
}
function get(url, data = {}, options = {}) {
  const queryString = Object.entries(data).map(
    ([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`
  ).join("&");
  const fullUrl = queryString ? `${url}?${queryString}` : url;
  return ajax({
    method: "GET",
    url: fullUrl,
    ...options
  });
}
function post(url, data, options = {}) {
  return ajax({
    method: "POST",
    url,
    data,
    headers: { "Content-Type": "application/json" },
    ...options
  });
}
function put(url, data, options = {}) {
  return ajax({
    method: "PUT",
    url,
    data,
    headers: { "Content-Type": "application/json" },
    ...options
  });
}
function patch(url, data, options = {}) {
  return ajax({
    method: "PATCH",
    url,
    data,
    headers: { "Content-Type": "application/json" },
    ...options
  });
}
function deleteRequest(url, data = {}, options = {}) {
  const queryString = Object.entries(data).map(
    ([key, value]) => `${encodeURIComponent(key)}=${encodeURIComponent(value)}`
  ).join("&");
  const fullUrl = queryString ? `${url}?${queryString}` : url;
  return ajax({
    method: "DELETE",
    url: fullUrl,
    ...options
  });
}

// src/core/ip.ts
function isValidIPv4(ip) {
  const ipv4Regex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;
  return ipv4Regex.test(ip);
}
function isValidIPv6(ip) {
  const ipv6Regex = /^(?:^([0-9a-fA-F]{1,4}:){7}([0-9a-fA-F]{1,4}|:)$)|(^([0-9a-fA-F]{1,4}:){1,7}:$)|(^([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}$)|(^([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}$)|(^([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}$)|(^([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}$)|(^([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}$)|(^([0-9a-fA-F]{1,4}:){1}(:[0-9a-fA-F]{1,4}){1,6}$)|(^:((:[0-9a-fA-F]{1,4}){1,7}|:)$)|(^([0-9a-fA-F]{1,4}:){1,7}:)$/;
  return ipv6Regex.test(ip);
}
function convertIPv4ToIPv6(ip) {
  if (!isValidIPv4(ip)) {
    console.error("Invalid IPv4 address provided.");
    return null;
  }
  const segments = ip.split(".").map(Number);
  const hexSegments = segments.map(
    (segment) => segment.toString(16).padStart(2, "0")
  );
  const ipv6 = `::ffff:${hexSegments.join(":")}`;
  return ipv6;
}
function convertIPv6ToIPv4(ip) {
  if (!isValidIPv6(ip)) {
    console.error("Invalid IPv6 address provided.");
    return null;
  }
  const ipv4Regex = /::ffff:([\da-f]{2}):([\da-f]{2}):([\da-f]{2}):([\da-f]{2})/i;
  const match = ip.match(ipv4Regex);
  if (!match) {
    console.error("Not a valid IPv6-mapped IPv4 address.");
    return null;
  }
  const ipv4Parts = match.slice(1, 5).map((hex) => parseInt(hex, 16));
  const ipv4 = ipv4Parts.join(".");
  return ipv4;
}
function normalizeIPv6(ip) {
  if (!isValidIPv6(ip)) return null;
  try {
    const segments = ip.split(":");
    let fullSegments = [];
    segments.forEach((segment) => {
      if (segment === "") {
        const fillLength = 8 - segments.filter((s) => s !== "").length;
        fullSegments.push(...Array(fillLength).fill("0000"));
      } else {
        fullSegments.push(segment.padStart(4, "0"));
      }
    });
    return fullSegments.join(":");
  } catch (e) {
    console.error("Error normalizing IPv6:", e);
    return null;
  }
}
function getIPVersion(ip) {
  if (isValidIPv4(ip)) return 4;
  if (isValidIPv6(ip)) return 6;
  return null;
}
function isPrivateIP(ip) {
  if (!isValidIPv4(ip)) return false;
  const privateRanges = [
    /^10\./,
    // 10.0.0.0 - 10.255.255.255
    /^172\.(1[6-9]|2[0-9]|3[0-1])\./,
    // 172.16.0.0 - 172.31.255.255
    /^192\.168\./
    // 192.168.0.0 - 192.168.255.255
  ];
  return privateRanges.some((range) => range.test(ip));
}
function generateRandomIPv4() {
  return Array(4).fill(0).map(() => Math.floor(Math.random() * 256)).join(".");
}
function generateRandomIPv6() {
  const getRandomHex = () => Math.floor(Math.random() * 65536).toString(16);
  const segments = Array.from({ length: 8 }, getRandomHex);
  return segments.join(":");
}
function isValidSubnetMask(mask) {
  const validMasks = [
    "255.255.255.255",
    "255.255.255.254",
    "255.255.255.252",
    "255.255.255.248",
    "255.255.255.240",
    "255.255.255.224",
    "255.255.255.192",
    "255.255.255.128",
    "255.255.255.0",
    "255.255.254.0",
    "255.255.252.0",
    "255.255.248.0",
    "255.255.240.0",
    "255.255.224.0",
    "255.255.192.0",
    "255.255.128.0",
    "255.255.0.0",
    "255.254.0.0",
    "255.252.0.0",
    "255.248.0.0",
    "255.240.0.0",
    "255.224.0.0",
    "255.192.0.0",
    "255.128.0.0",
    "255.0.0.0"
  ];
  return validMasks.includes(mask);
}
function extractFromCIDR(cidr) {
  const cidrRegex = /^([\d\.]+)\/(\d{1,2})$/;
  const match = cidr.match(cidrRegex);
  if (!match || !isValidIPv4(match[1]) || parseInt(match[2]) > 32)
    return null;
  const ip = match[1];
  const prefixLength = parseInt(match[2]);
  const maskBinary = "1".repeat(prefixLength).padEnd(32, "0");
  const mask = maskBinary.match(/.{8}/g)?.map((bin) => parseInt(bin, 2)).join(".") || "";
  return { ip, mask };
}
function calculateNetworkAddress(ip, mask) {
  if (!isValidIPv4(ip) || !isValidSubnetMask(mask)) return null;
  const ipSegments = ip.split(".").map(Number);
  const maskSegments = mask.split(".").map(Number);
  const networkAddress = ipSegments.map(
    (segment, i) => segment & maskSegments[i]
  );
  return networkAddress.join(".");
}
function areIPsInSameNetwork(ip1, ip2, mask) {
  const network1 = calculateNetworkAddress(ip1, mask);
  const network2 = calculateNetworkAddress(ip2, mask);
  return network1 === network2;
}
function getLocationByIP(ip, callback) {
  const apiUrl = `https://ipinfo.io/${ip}/json`;
  get(
    apiUrl,
    {},
    {
      responseType: "json",
      useFetch: true,
      error: (error) => {
        console.error("Error fetching geolocation information:", error);
        callback(null);
      },
      success: (response) => {
        const data = response;
        const location = {
          latitude: parseFloat(data.loc.split(",")[0]),
          longitude: parseFloat(data.loc.split(",")[1])
        };
        callback(location);
      }
    }
  );
}
function getUserIPAddress(callback) {
  const apiUrl = "https://api.ipify.org?format=json";
  get(
    apiUrl,
    {},
    {
      responseType: "json",
      useFetch: true,
      error: (error) => {
        console.error("Error fetching ip information:", error);
        callback(null);
      },
      success: (response) => {
        const data = response;
        const ip = data.ip;
        if (isValidIPv4(ip)) {
          callback(ip);
        }
      }
    }
  );
}

// src/core/url.ts
function parseQueryStringParameters(queryString, decode = true) {
  const params = {};
  if (!queryString || typeof queryString !== "string") {
    return params;
  }
  queryString = queryString.startsWith("?") ? queryString.slice(1) : queryString;
  const pairs = queryString.split("&");
  for (const pair of pairs) {
    const [key, value] = pair.split("=");
    const decodedKey = decode ? decodeURIComponent(key) : key;
    const decodedValue = value ? decode ? decodeURIComponent(value) : value : "";
    if (params.hasOwnProperty(decodedKey)) {
      if (Array.isArray(params[decodedKey])) {
        params[decodedKey].push(decodedValue);
      } else {
        params[decodedKey] = [params[decodedKey], decodedValue];
      }
    } else {
      params[decodedKey] = decodedValue;
    }
  }
  return params;
}
function replaceQueryStringParameter(url, key, value, encode = true) {
  if (!url || typeof url !== "string") {
    return url;
  }
  const [baseUrl, queryString] = url.split("?");
  const params = {};
  if (queryString) {
    const pairs = queryString.split("&");
    for (const pair of pairs) {
      const [existingKey, existingValue] = pair.split("=");
      const decodedKey = decodeURIComponent(existingKey);
      const decodedValue = existingValue ? decodeURIComponent(existingValue) : "";
      params[decodedKey] = decodedValue;
    }
  }
  const keyToUse = encode ? encodeURIComponent(key) : key;
  const valueToUse = encode ? encodeURIComponent(value) : value;
  params[keyToUse] = valueToUse;
  const newQueryString = Object.entries(params).map(([k, v]) => `${k}=${v}`).join("&");
  return newQueryString ? `${baseUrl}?${newQueryString}` : baseUrl;
}
function removeQueryStringParameter(url, key) {
  if (!url || typeof url !== "string") {
    return url;
  }
  const [baseUrl, queryString] = url.split("?");
  const params = {};
  if (queryString) {
    const pairs = queryString.split("&");
    for (const pair of pairs) {
      const [existingKey, existingValue] = pair.split("=");
      const decodedKey = decodeURIComponent(existingKey);
      const decodedValue = existingValue ? decodeURIComponent(existingValue) : "";
      params[decodedKey] = decodedValue;
    }
    delete params[key];
  }
  const newQueryString = Object.entries(params).map(([k, v]) => `${k}=${v}`).join("&");
  return newQueryString ? `${baseUrl}?${newQueryString}` : baseUrl;
}
function mergeURL(baseURL, relativeURL) {
  const base = new URL(baseURL);
  const relative = new URL(relativeURL, base);
  relative.search = relative.search || base.search;
  relative.hash = relative.hash || base.hash;
  return relative.href;
}
function normalizeURL(url) {
  try {
    const normalized = new URL(url);
    normalized.hash = normalized.hash.replace(/#$/, "");
    return normalized.href;
  } catch (error) {
    console.error("Invalid URL provided for normalization:", error);
    return url;
  }
}
function extractFragment(url) {
  try {
    const fragment = new URL(url).hash.substring(1);
    return decodeURIComponent(fragment);
  } catch {
    console.error("Failed to extract or decode fragment from URL:", url);
    return "";
  }
}
function constructURL(base, path = "", queryParams = {}) {
  try {
    const url = new URL(base);
    if (path) url.pathname = path;
    Object.entries(queryParams).forEach(([key, value]) => {
      url.searchParams.set(key, value);
    });
    return url.href;
  } catch (error) {
    console.error("Error constructing URL:", error);
    return "";
  }
}

// src/utils/sw.ts
var retryFailedRequests = async (url, retryDelay = 5, maxRetry = 3) => {
  let retryCount = 0;
  while (retryCount < maxRetry) {
    try {
      await fetch(url);
      console.log("Request successful");
      return;
    } catch (error) {
      retryCount++;
      console.warn(
        `Retrying request (${retryCount}/${maxRetry}) after ${retryDelay} seconds...`
      );
      await delay(retryDelay * 1e3);
    }
  }
  console.error("Failed to complete request after retries");
};
var delay = (ms) => new Promise((resolve) => setTimeout(resolve, ms));

// src/core/sw.ts
async function registerServiceWorker(swPath, options) {
  if ("serviceWorker" in navigator) {
    try {
      const registration = await navigator.serviceWorker.register(
        swPath,
        {
          scope: options?.scope,
          updateViaCache: options?.updateViaCache || "all"
        }
      );
      if (options?.onUpdateFound) {
        registration.onupdatefound = () => {
          const newWorker = registration.installing;
          const oldVersion = registration.active?.scriptURL || "none";
          if (newWorker) {
            newWorker.onstatechange = () => {
              if (newWorker.state === "installed" && navigator.serviceWorker.controller) {
                options.onUpdateFound(
                  oldVersion,
                  newWorker.scriptURL
                );
              }
            };
          }
        };
      }
      return registration;
    } catch (error) {
      console.error("Service Worker registration failed:", error);
    }
  }
  return void 0;
}
async function handleCachingStrategy(request, options) {
  const cache = await caches.open(options.cacheName);
  if (options.cacheFirst) {
    const cachedResponse = await cache.match(request);
    return cachedResponse || fetch(request).then(async (networkResponse) => {
      await cache.put(request, networkResponse.clone());
      return networkResponse;
    });
  } else {
    const fetchPromise = fetch(request).then(async (networkResponse) => {
      await cache.put(request, networkResponse.clone());
      return networkResponse;
    });
    if (options.networkTimeoutSeconds) {
      const timeoutPromise = new Promise((resolve, reject) => {
        setTimeout(
          async () => {
            const cachedResponse = await cache.match(request);
            cachedResponse ? resolve(cachedResponse) : reject("Request timed out");
          },
          options.networkTimeoutSeconds * 1e3
        );
      });
      return Promise.race([fetchPromise, timeoutPromise]);
    }
    return fetchPromise.catch(async () => {
      const cachedResponse = await cache.match(request);
      if (cachedResponse) return cachedResponse;
      throw new Error("Network and cache failed");
    });
  }
}
async function handleBackgroundSync(url, options) {
  if ("serviceWorker" in navigator && "SyncManager" in window) {
    try {
      const registration = await navigator.serviceWorker.ready;
      const syncRegistration = registration;
      if (syncRegistration.sync) {
        await syncRegistration.sync.register(options.tag);
        console.log(
          `Background sync registered with tag: ${options.tag}`
        );
      } else {
        console.warn("SyncManager is not supported in this browser.");
      }
      self.addEventListener("sync", (event) => {
        if (event.tag === options.tag) {
          event.waitUntil(
            retryFailedRequests(
              url,
              options.retryDelay,
              options.maxRetry
            )
          );
        }
      });
    } catch (err) {
      console.error("Background sync registration failed:", err);
    }
  } else {
    console.warn("Background sync is not supported in this browser.");
  }
}
function showPushNotification(registration, options) {
  const notificationOptions = {
    body: options.body,
    icon: options.icon ?? "/images/default-icon.png"
    // Use nullish coalescing for a safer default
  };
  registration.showNotification(options.title, notificationOptions);
  if (options.onNotificationClick) {
    const clickHandler = (event) => {
      event.notification.close();
      options.onNotificationClick(event);
    };
    self.removeEventListener("notificationclick", clickHandler);
    self.addEventListener("notificationclick", clickHandler);
  }
}
function sendMessageToSW(message) {
  if (navigator.serviceWorker.controller) {
    return new Promise((resolve, reject) => {
      const messageChannel = new MessageChannel();
      messageChannel.port1.onmessage = (event) => {
        if (event.data && event.data.error) {
          reject(event.data.error);
        } else {
          resolve(event.data);
        }
      };
      navigator.serviceWorker.controller.postMessage(message, [
        messageChannel.port2
      ]);
    });
  } else {
    return Promise.reject("No Service Worker controller found");
  }
}

// src/modules/ip.ts
var IP = {
  isPrivateIP,
  isValidIPv4,
  isValidIPv6,
  isValidSubnetMask,
  calculateNetworkAddress,
  convertIPv4ToIPv6,
  convertIPv6ToIPv4,
  generateRandomIPv4,
  generateRandomIPv6,
  getIPVersion,
  getLocationByIP,
  getUserIPAddress,
  extractFromCIDR,
  areIPsInSameNetwork,
  normalizeIPv6
};
var ip_default = IP;

// src/modules/request.ts
var Request = {
  ajax,
  get,
  patch,
  post,
  put,
  deleteRequest
};
var request_default = Request;

// src/modules/sw.ts
var SW = {
  handleBackgroundSync,
  handleCachingStrategy,
  showPushNotification,
  sendMessageToSW,
  registerServiceWorker
};
var sw_default = SW;

// src/modules/url.ts
var URL2 = {
  constructURL,
  parseQueryStringParameters,
  removeQueryStringParameter,
  replaceQueryStringParameter,
  extractFragment,
  mergeURL,
  normalizeURL
};
var url_default = URL2;

// src/index.ts
var Network = {
  isPrivateIP,
  isValidIPv4,
  isValidIPv6,
  isValidSubnetMask,
  calculateNetworkAddress,
  convertIPv4ToIPv6,
  convertIPv6ToIPv4,
  generateRandomIPv4,
  generateRandomIPv6,
  getIPVersion,
  getLocationByIP,
  getUserIPAddress,
  extractFromCIDR,
  areIPsInSameNetwork,
  normalizeIPv6,
  ajax,
  get,
  patch,
  post,
  put,
  deleteRequest,
  handleBackgroundSync,
  handleCachingStrategy,
  showPushNotification,
  registerServiceWorker,
  sendMessageToSW,
  constructURL,
  parseQueryStringParameters,
  removeQueryStringParameter,
  replaceQueryStringParameter,
  extractFragment,
  mergeURL,
  normalizeURL
};
var src_default = Network;
export {
  ip_default as IP,
  request_default as Request,
  sw_default as SW,
  url_default as URL,
  ajax,
  areIPsInSameNetwork,
  calculateNetworkAddress,
  constructURL,
  convertIPv4ToIPv6,
  convertIPv6ToIPv4,
  src_default as default,
  deleteRequest,
  extractFragment,
  extractFromCIDR,
  generateRandomIPv4,
  generateRandomIPv6,
  get,
  getIPVersion,
  getLocationByIP,
  getUserIPAddress,
  handleBackgroundSync,
  handleCachingStrategy,
  isPrivateIP,
  isValidIPv4,
  isValidIPv6,
  isValidSubnetMask,
  mergeURL,
  normalizeIPv6,
  normalizeURL,
  parseQueryStringParameters,
  patch,
  post,
  put,
  registerServiceWorker,
  removeQueryStringParameter,
  replaceQueryStringParameter,
  sendMessageToSW,
  showPushNotification
};
