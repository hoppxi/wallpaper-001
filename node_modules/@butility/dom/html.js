// src/core/element.ts
function create(name, options = {}, callback) {
  const element = document.createElement(name);
  if (options.class && Array.isArray(options.class)) {
    options.class.forEach((className) => {
      if (className) {
        element.classList.add(className);
      }
    });
  }
  if (options.attr) {
    for (const key in options.attr) {
      if (Object.hasOwnProperty.call(options.attr, key)) {
        element.setAttribute(key, options.attr[key]);
      }
    }
  }
  if (options.innerText) element.innerText = options.innerText;
  if (options.innerHTML) element.innerHTML = options.innerHTML;
  if (options.children && Array.isArray(options.children)) {
    options.children.forEach((child) => {
      if (child instanceof HTMLElement) {
        element.appendChild(child);
      }
    });
  }
  if (options.draggable) element.draggable = true;
  if (options.style) element.style.cssText = options.style;
  if (options.trackMutation) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        console.log("Mutation observed:", mutation);
      });
    });
    observer.observe(element, {
      attributes: true,
      childList: true,
      subtree: true
    });
  }
  if (callback && typeof callback === "function") callback(element);
  return element;
}

// src/core/attribute.ts
function setAttribute(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(
      attribute
    )) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log)
            console.log(
              `Skipping attribute: ${finalAttributeName}`
            );
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(
            `Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`
          );
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log)
            console.log(
              `Set data attribute: data-${dataKey} = ${transformedValue}`
            );
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log)
            console.log(
              `Set attribute: ${finalAttributeName} = ${transformedValue}`
            );
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}

// src/utils/create-helper.ts
function setAttributeOrChildren(element, ...attributesOrChildren) {
  attributesOrChildren.forEach((item) => {
    if (typeof item === "object" && !(item instanceof HTMLElement)) {
      setAttribute(element, item);
    } else if (item instanceof HTMLElement || typeof item === "string") {
      element.append(item);
    }
  });
}

// src/core/html.ts
var tags = [
  "button",
  "span",
  "div",
  "a",
  "p",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "ul",
  "ol",
  "li",
  "img",
  "input",
  "form",
  "table",
  "tr",
  "td",
  "th",
  "tbody",
  "thead",
  "tfoot",
  "textarea",
  "select",
  "option",
  "section",
  "article",
  "aside",
  "header",
  "footer",
  "nav",
  "main",
  "figure",
  "figcaption",
  "audio",
  "video",
  "source",
  "canvas",
  "details",
  "summary",
  "datalist",
  "fieldset",
  "legend",
  "label",
  "meter",
  "progress",
  "time",
  "output",
  "iframe",
  "object",
  "embed",
  "picture",
  "track",
  "map",
  "area",
  "base",
  "link",
  "style",
  "script",
  "title",
  "meta",
  "abbr",
  "bdi",
  "dialog",
  "mark"
];
function createElementWithAttributes(tag, ...attributesOrChildren) {
  const element = create(tag);
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}
var elements = Object.fromEntries(
  tags.map((tag) => [
    tag,
    (...attributesOrChildren) => createElementWithAttributes(tag, ...attributesOrChildren)
  ])
);
function custom(name, ...attributesOrChildren) {
  const element = create(name);
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}
function body(...attributesOrChildren) {
  setAttributeOrChildren(document.body, ...attributesOrChildren);
  return document.body;
}
function head(...attributesOrChildren) {
  setAttributeOrChildren(document.head, ...attributesOrChildren);
  return document.head;
}
var button = elements.button;
var span = elements.span;
var div = elements.div;
var a = elements.a;
var p = elements.p;
var h1 = elements.h1;
var h2 = elements.h2;
var h3 = elements.h3;
var h4 = elements.h4;
var h5 = elements.h5;
var h6 = elements.h6;
var ul = elements.ul;
var ol = elements.ol;
var li = elements.li;
var img = elements.img;
var input = elements.input;
var form = elements.form;
var table = elements.table;
var tr = elements.tr;
var td = elements.td;
var th = elements.th;
var tbody = elements.tbody;
var thead = elements.thead;
var tfoot = elements.tfoot;
var textarea = elements.textarea;
var select = elements.select;
var option = elements.option;
var section = elements.section;
var article = elements.article;
var aside = elements.aside;
var header = elements.header;
var footer = elements.footer;
var nav = elements.nav;
var main = elements.main;
var figure = elements.figure;
var figcaption = elements.figcaption;
var audio = elements.audio;
var video = elements.video;
var source = elements.source;
var canvas = elements.canvas;
var details = elements.details;
var summary = elements.summary;
var datalist = elements.datalist;
var fieldset = elements.fieldset;
var legend = elements.legend;
var label = elements.label;
var meter = elements.meter;
var progress = elements.progress;
var time = elements.time;
var output = elements.output;
var iframe = elements.iframe;
var object = elements.object;
var embed = elements.embed;
var picture = elements.picture;
var track = elements.track;
var map = elements.map;
var area = elements.area;
var base = elements.base;
var link = elements.link;
var style = elements.style;
var script = elements.script;
var title = elements.title;
var meta = elements.meta;
var abbr = elements.abbr;
var bdi = elements.bdi;
var dialog = elements.dialog;
var mark = elements.mark;
export {
  a,
  abbr,
  area,
  article,
  aside,
  audio,
  base,
  bdi,
  body,
  button,
  canvas,
  custom,
  datalist,
  details,
  dialog,
  div,
  embed,
  fieldset,
  figcaption,
  figure,
  footer,
  form,
  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  head,
  header,
  iframe,
  img,
  input,
  label,
  legend,
  li,
  link,
  main,
  map,
  mark,
  meta,
  meter,
  nav,
  object,
  ol,
  option,
  output,
  p,
  picture,
  progress,
  script,
  section,
  select,
  source,
  span,
  style,
  summary,
  table,
  tbody,
  td,
  textarea,
  tfoot,
  th,
  thead,
  time,
  title,
  tr,
  track,
  ul,
  video
};
