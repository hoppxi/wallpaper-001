// src/core/class.ts
function addClass(element, className, options = {}) {
  if (!(element instanceof HTMLElement)) {
    throw new Error("Invalid element provided.");
  }
  if (typeof className !== "string" || !className.trim()) {
    throw new Error("Invalid className provided.");
  }
  const { checkIfExists = false } = options;
  if (checkIfExists && element.classList.contains(className)) {
    console.warn(`Class "${className}" already exists on the element.`);
    return;
  }
  element.classList.add(className);
}
function removeClass(element, className, options = {}) {
  if (!(element instanceof HTMLElement)) {
    throw new Error("Invalid element provided.");
  }
  if (typeof className !== "string" || !className.trim()) {
    throw new Error("Invalid className provided.");
  }
  const { logChanges = false, preserveState = false } = options;
  if (preserveState) {
    element.dataset.previousClassList = element.className;
  }
  element.classList.remove(className);
  if (logChanges) {
    console.log(`Class "${className}" removed from element.`);
  }
}
function toggleClass(element, className, options = {}) {
  if (!(element instanceof HTMLElement)) {
    throw new Error("Invalid element provided.");
  }
  if (typeof className !== "string" || !className.trim()) {
    throw new Error("Invalid className provided.");
  }
  const { onAdd, onRemove } = options;
  if (element.classList.toggle(className)) {
    if (typeof onAdd === "function") {
      onAdd(element);
    }
  } else {
    if (typeof onRemove === "function") {
      onRemove(element);
    }
  }
}
function replaceClass(element, oldClass, newClass, options = {}) {
  if (!(element instanceof HTMLElement)) {
    throw new Error("Invalid element provided.");
  }
  if (typeof oldClass !== "string" || !oldClass.trim() || typeof newClass !== "string" || !newClass.trim()) {
    throw new Error("Invalid class names provided.");
  }
  const { enableUndo = false } = options;
  removeClass(element, oldClass);
  addClass(element, newClass);
  if (enableUndo) {
    const undo = () => {
      removeClass(element, newClass);
      addClass(element, oldClass);
      console.log(
        `Undo: Class "${newClass}" replaced back with "${oldClass}".`
      );
    };
    return undo;
  }
  return null;
}
async function addClasses(element, classNames, options = {}) {
  if (!(element instanceof HTMLElement)) {
    throw new Error("Invalid element provided.");
  }
  if (!Array.isArray(classNames) || classNames.some((name) => typeof name !== "string" || !name.trim())) {
    throw new Error("Invalid classNames provided.");
  }
  const { timeout = 0, checkForDuplicates = false } = options;
  if (timeout > 0) {
    await new Promise((resolve) => setTimeout(resolve, timeout));
  }
  classNames.forEach((className) => {
    if (!checkForDuplicates || !element.classList.contains(className)) {
      element.classList.add(className);
    }
  });
}
function replaceClasses(element, classMap) {
  for (const oldClass in classMap) {
    if (classMap.hasOwnProperty(oldClass)) {
      replaceClass(element, oldClass, classMap[oldClass]);
    }
  }
}
function toggleClassConditionally(element, condition, trueClass, falseClass) {
  if (condition) {
    addClass(element, trueClass);
    removeClass(element, falseClass);
  } else {
    addClass(element, falseClass);
    removeClass(element, trueClass);
  }
}
function hasAnyClass(element, classArray) {
  for (const className of classArray) {
    if (typeof className === "string" && element.classList.contains(className)) {
      return true;
    }
  }
  return false;
}
function replaceClassPrefix(element, oldPrefix, newPrefix) {
  const classNames = Array.from(element.classList);
  classNames.forEach((className) => {
    if (className.startsWith(oldPrefix)) {
      removeClass(element, className);
      addClass(element, className.replace(oldPrefix, newPrefix));
    }
  });
}
function addUniqueClass(element, className) {
  if (!element.classList.contains(className)) {
    addClass(element, className);
  }
}
function addClassOnViewportEnter(element, className) {
  const handleScroll = () => {
    const rect = element.getBoundingClientRect();
    if (rect.top >= 0 && rect.bottom <= window.innerHeight) {
      addClass(element, className);
      window.removeEventListener("scroll", handleScroll);
    }
  };
  window.addEventListener("scroll", handleScroll);
  handleScroll();
}
function toggleClassOnFocus(element, className) {
  element.addEventListener("focus", () => {
    addClass(element, className);
  });
  element.addEventListener("blur", () => {
    removeClass(element, className);
  });
}
function toggleClassOnMediaQueryChange(element, className, mediaQuery) {
  const mediaQueryList = window.matchMedia(mediaQuery);
  const handleMediaQueryChange = (event) => {
    if (event.matches) {
      toggleClass(element, className);
    }
  };
  mediaQueryList.addListener(handleMediaQueryChange);
  handleMediaQueryChange(mediaQueryList);
}
function toggleClassOnCopy(element, className) {
  element.addEventListener("copy", () => {
    toggleClass(element, className);
  });
}
function toggleClassOnIdleTime(element, className, idleTime = 3e4) {
  let idleTimer;
  const resetIdleTimer = () => {
    clearTimeout(idleTimer);
    idleTimer = setTimeout(() => {
      toggleClass(element, className);
    }, idleTime);
  };
  document.addEventListener("mousemove", resetIdleTimer);
  document.addEventListener("keypress", resetIdleTimer);
  resetIdleTimer();
}
function addClassOnInterval(element, className, interval = 1e3) {
  setInterval(() => {
    addClass(element, className);
  }, interval);
}
function removeClassOnInterval(element, className, interval = 1e3) {
  setInterval(() => {
    removeClass(element, className);
  }, interval);
}
function toggleClassOnDeviceMotion(element, className) {
  window.addEventListener("deviceorientation", (event) => {
    const tiltThreshold = 20;
    const isTilted = Math.abs(event.beta) > tiltThreshold || Math.abs(event.gamma) > tiltThreshold;
    if (isTilted) {
      toggleClass(element, className);
    }
  });
}
function toggleClassOnOrientationChange(element, className) {
  const handleOrientationChange = () => {
    const orientation = window.matchMedia("(orientation: portrait)").matches ? "portrait" : "landscape";
    toggleClass(element, `${className}-${orientation}`);
  };
  window.addEventListener("orientationchange", handleOrientationChange);
  handleOrientationChange();
}
function toggleClassOnSwipe(element, className) {
  let startX, startY;
  element.addEventListener("touchstart", (event) => {
    startX = event.touches[0].clientX;
    startY = event.touches[0].clientY;
  });
  element.addEventListener("touchend", (event) => {
    const deltaX = event.changedTouches[0].clientX - startX;
    const deltaY = event.changedTouches[0].clientY - startY;
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      toggleClass(element, `${className}-horizontal`);
    } else {
      toggleClass(element, `${className}-vertical`);
    }
  });
}
function toggleClassOnConnectionStatus(element, trueClass, falseClass) {
  const handleConnectionChange = () => {
    const isOnline = navigator.onLine;
    toggleClassConditionally(element, isOnline, trueClass, falseClass);
  };
  window.addEventListener("online", handleConnectionChange);
  window.addEventListener("offline", handleConnectionChange);
  handleConnectionChange();
}
function toggleClassOnGeolocationChange(element, className, options = {}) {
  if (!(element instanceof HTMLElement)) {
    throw new Error("Invalid element provided.");
  }
  if (typeof className !== "string" || !className.trim()) {
    throw new Error("Invalid className provided.");
  }
  const {
    enableThrottling = true,
    throttleInterval = 5e3,
    onClassToggle = null,
    onError = null,
    geoOptions = {
      enableHighAccuracy: true,
      timeout: 1e4,
      maximumAge: 0
    }
  } = options;
  let lastToggleTime = 0;
  let classToggled = false;
  const toggleClassWithConditions = (position) => {
    const currentTime = Date.now();
    if (enableThrottling && currentTime - lastToggleTime < throttleInterval) {
      console.log("Throttling geolocation updates, skipping toggle.");
      return;
    }
    toggleClass(element, className);
    if (typeof onClassToggle === "function") {
      onClassToggle(position, classToggled);
    }
    classToggled = !classToggled;
    lastToggleTime = currentTime;
  };
  const handleGeolocationError = (error) => {
    console.error("Geolocation error occurred:", error.message);
    if (typeof onError === "function") {
      onError(error);
    }
  };
  const geoWatchId = navigator.geolocation.watchPosition(
    toggleClassWithConditions,
    handleGeolocationError,
    geoOptions
  );
  console.log("Started watching geolocation changes with ID:", geoWatchId);
  return () => {
    navigator.geolocation.clearWatch(geoWatchId);
    console.log("Stopped watching geolocation changes.");
  };
}

// src/modules/class.ts
var ClassUtils = {
  add: addClass,
  addOnInterval: addClassOnInterval,
  addOnViewportEnter: addClassOnViewportEnter,
  addMany: addClasses,
  addUnique: addUniqueClass,
  hasAny: hasAnyClass,
  remove: removeClass,
  removeOnInterval: removeClassOnInterval,
  replace: replaceClass,
  replacePrefix: replaceClassPrefix,
  replaceMany: replaceClasses,
  toggle: toggleClass,
  toggleConditionally: toggleClassConditionally,
  toggleOnConnectionStatus: toggleClassOnConnectionStatus,
  toggleOnCopy: toggleClassOnCopy,
  toggleOnDeviceMotion: toggleClassOnDeviceMotion,
  toggleOnFocus: toggleClassOnFocus,
  toggleOnGeolocationChange: toggleClassOnGeolocationChange,
  toggleOnIdleTime: toggleClassOnIdleTime,
  toggleOnMediaQueryChange: toggleClassOnMediaQueryChange,
  toggleOnOrientationChange: toggleClassOnOrientationChange,
  toggleOnSwipe: toggleClassOnSwipe
};
var class_default = ClassUtils;
export {
  addClass,
  addClassOnInterval,
  addClassOnViewportEnter,
  addClasses,
  addUniqueClass,
  class_default as default,
  hasAnyClass,
  removeClass,
  removeClassOnInterval,
  replaceClass,
  replaceClassPrefix,
  replaceClasses,
  toggleClass,
  toggleClassConditionally,
  toggleClassOnConnectionStatus,
  toggleClassOnCopy,
  toggleClassOnDeviceMotion,
  toggleClassOnFocus,
  toggleClassOnGeolocationChange,
  toggleClassOnIdleTime,
  toggleClassOnMediaQueryChange,
  toggleClassOnOrientationChange,
  toggleClassOnSwipe
};
