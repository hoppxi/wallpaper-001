// src/core/attribute.ts
function setAttribute(element, attribute, options = {}) {
  const {
    whitelist,
    blacklist,
    validate,
    transformValue,
    addPrefix = "",
    // By default, no prefix is added
    onAttributeSet = () => {
    },
    // Default no-op callback
    onError = (error) => console.error(error),
    // Default error handler logs to console
    log = false
    // Disable logging by default
  } = options;
  let settedAttributes = {};
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof attribute !== "object") {
      throw new Error("Attribute name must be a non-empty string.");
    }
    const shouldSetAttribute = (key) => {
      if (whitelist && !whitelist.includes(key)) return false;
      if (blacklist && blacklist.includes(key)) return false;
      return true;
    };
    for (const [attributeName, attributeValue] of Object.entries(
      attribute
    )) {
      try {
        const finalAttributeName = addPrefix ? `${addPrefix}${attributeName}` : attributeName;
        if (!shouldSetAttribute(finalAttributeName)) {
          if (log)
            console.log(
              `Skipping attribute: ${finalAttributeName}`
            );
          return;
        }
        if (validate && !validate(finalAttributeName, attributeValue)) {
          throw new Error(
            `Validation failed for attribute: ${finalAttributeName} with value: ${attributeValue}`
          );
        }
        const transformedValue = transformValue ? transformValue(finalAttributeName, attributeValue) : attributeValue;
        if (/^data-/.test(finalAttributeName)) {
          const dataKey = finalAttributeName.slice(5);
          element.dataset[dataKey] = transformedValue;
          if (log)
            console.log(
              `Set data attribute: data-${dataKey} = ${transformedValue}`
            );
        } else {
          element.setAttribute(finalAttributeName, transformedValue);
          if (log)
            console.log(
              `Set attribute: ${finalAttributeName} = ${transformedValue}`
            );
        }
        Object.defineProperty(settedAttributes, finalAttributeName, {
          value: transformedValue,
          writable: true,
          enumerable: true,
          configurable: true
        });
      } catch (error) {
        onError(error);
      }
    }
    onAttributeSet(settedAttributes);
  } catch (error) {
    onError(error);
  }
}
function removeAttribute(element, attributeName) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  if (/^data-/.test(attributeName)) {
    delete element.dataset[attributeName.slice(5)];
  } else if (element.hasAttribute(attributeName)) {
    element.removeAttribute(attributeName);
  } else {
    console.warn(`Attribute "${attributeName}" does not exist on`, element);
  }
}
function getAttribute(element, attributeName, options) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const result = {};
  let value;
  if (options?.dataPrefix && /^data-/.test(attributeName)) {
    value = element.dataset[attributeName.slice(5)] || null;
  } else {
    value = element.getAttribute(attributeName);
  }
  if (options?.transform) {
    value = options.transform(value);
  }
  result[attributeName] = value !== null ? value : options?.defaultValue || null;
  return result;
}
function getAllAttributes(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const attributes = {};
  Array.from(element.attributes).forEach((attr) => {
    attributes[attr.name] = attr.value;
  });
  Object.keys(element.dataset).forEach((dataKey) => {
    const dataValue = element.dataset[dataKey];
    if (dataValue !== void 0) {
      attributes[`data-${dataKey}`] = dataValue;
    }
  });
  return attributes;
}
function hasAttribute(element, attributeName) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  return /^data-/.test(attributeName) ? attributeName.slice(5) in element.dataset : element.hasAttribute(attributeName);
}
function toggleAttribute(element, attributeName, attributeValue) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  if (hasAttribute(element, attributeName)) {
    removeAttribute(element, attributeName);
  } else {
    setAttribute(element, {
      [attributeName]: attributeValue
    });
  }
}
function removeAllAttributes(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  Array.from(element.attributes).forEach((attr) => {
    element.removeAttribute(attr.name);
  });
  Object.keys(element.dataset).forEach((dataKey) => {
    delete element.dataset[dataKey];
  });
}
function attributesToQueryString(element) {
  if (!element || !(element instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  const attributes = Array.from(element.attributes);
  return attributes.map(
    (attr) => `${encodeURIComponent(attr.name)}=${encodeURIComponent(attr.value)}`
  ).join("&");
}
function copyAttributes(element, target) {
  if (!element || !(element instanceof HTMLElement) || !target || !(target instanceof HTMLElement)) {
    throw new Error("Invalid HTMLElement provided.");
  }
  Array.from(element.attributes).forEach((attr) => {
    setAttribute(target, { [attr.name]: attr.value });
  });
}
function findElementByAttribute(Element2, attributeName) {
  return Array.from(
    Element2.querySelectorAll(`[${attributeName}]`)
  );
}
function toggleAttributes(element, attributes) {
  Object.keys(attributes).forEach((attr) => {
    if (attributes[attr]) {
      element.setAttribute(attr, "");
    } else {
      element.removeAttribute(attr);
    }
  });
}
function hasAnyAttributes(element) {
  return element.attributes.length > 0;
}
function removeAttributesByName(element, ...attributeNames) {
  attributeNames.forEach((attr) => {
    element.removeAttribute(attr);
  });
}
function getAttributesByPrefix(element, prefix) {
  const result = {};
  Array.from(element.attributes).forEach((attr) => {
    if (attr.name.startsWith(prefix)) {
      result[attr.name] = attr.value;
    }
  });
  return result;
}
function setAttributesFromQueryString(element, queryString, options = {}) {
  const { onError = (error) => console.error(error) } = options;
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    if (typeof queryString !== "string" || !queryString.trim()) {
      throw new Error(
        "Invalid queryString provided. It must be a non-empty string."
      );
    }
    const params = new URLSearchParams(queryString);
    try {
      setAttribute(element, params, options);
    } catch (attrError) {
      onError(attrError);
    }
  } catch (error) {
    onError(error);
  }
}
function compareAttributes(el1, el2, options = {}) {
  const diff = {};
  try {
    if (!(el1 instanceof HTMLElement) || !(el2 instanceof HTMLElement)) {
      throw new TypeError("Both el1 and el2 must be valid HTMLElements.");
    }
    const el1Attributes = el1.attributes;
    const el2Attributes = el2.attributes;
    const {
      onTrue = () => {
      },
      // Default no-op callback if not provided
      onFalse = () => {
      },
      // Default no-op callback if not provided
      ignoreAttributes = [],
      customCompare
    } = options;
    const shouldIgnore = (attrName) => ignoreAttributes.includes(attrName);
    Array.from(el1Attributes).forEach((attr) => {
      const el2Value = el2.getAttribute(attr.name);
      if (shouldIgnore(attr.name)) return;
      const isEqual = customCompare ? customCompare(attr.value, el2Value) : attr.value === el2Value;
      if (!isEqual) {
        diff[attr.name] = { el1Value: attr.value, el2Value };
        onFalse(attr.name, attr.value, el2Value);
      } else {
        onTrue(attr.name, attr.value, el2Value);
      }
    });
    Array.from(el2Attributes).forEach((attr) => {
      if (!el1.hasAttribute(attr.name) && !shouldIgnore(attr.name)) {
        diff[attr.name] = { el1Value: null, el2Value: attr.value };
        onFalse(attr.name, null, attr.value);
      }
    });
  } catch (error) {
    console.error(`Error comparing attributes: ${error.message}`);
  }
  return diff;
}
function removeAttributesByPrefix(element, prefixes, options) {
  const { onRemove, protectedAttr } = options;
  try {
    if (!(element instanceof HTMLElement)) {
      throw new TypeError("Provided element is not a valid HTMLElement.");
    }
    const prefixList = Array.isArray(prefixes) ? prefixes : [prefixes];
    if (prefixList.length === 0 || prefixList.some(
      (prefix) => typeof prefix !== "string" || !prefix.trim()
    )) {
      throw new Error(
        "Invalid prefixes provided. Prefixes must be non-empty strings."
      );
    }
    Array.from(element.attributes).forEach((attr) => {
      const attrName = attr.name;
      const shouldRemove = prefixList.some(
        (prefix) => attrName.startsWith(prefix)
      );
      if (shouldRemove) {
        if (typeof onRemove === "function") {
          onRemove(attrName);
        }
        const isRemovable = (attrName2) => {
          if (protectedAttr) {
            return !protectedAttr.includes(attrName2);
          }
        };
        if (isRemovable(attrName) === true) {
          element.removeAttribute(attrName);
        }
      }
    });
  } catch (error) {
    console.error(
      `Error while removing attributes by prefix: ${error.message}`
    );
  }
}

// src/modules/attribute.ts
var Attribute = {
  toQueryString: attributesToQueryString,
  compare: compareAttributes,
  copy: copyAttributes,
  findElement: findElementByAttribute,
  getAll: getAllAttributes,
  get: getAttribute,
  getByPrefix: getAttributesByPrefix,
  hasAny: hasAnyAttributes,
  has: hasAttribute,
  removeAll: removeAllAttributes,
  remove: removeAttribute,
  removeByName: removeAttributesByName,
  removeByPrefix: removeAttributesByPrefix,
  set: setAttribute,
  setFromQueryString: setAttributesFromQueryString,
  toggle: toggleAttribute,
  toggleMany: toggleAttributes
};
var attribute_default = Attribute;

// src/core/class.ts
function addClass(element, className, options = {}) {
  if (!(element instanceof HTMLElement)) {
    throw new Error("Invalid element provided.");
  }
  if (typeof className !== "string" || !className.trim()) {
    throw new Error("Invalid className provided.");
  }
  const { checkIfExists = false } = options;
  if (checkIfExists && element.classList.contains(className)) {
    console.warn(`Class "${className}" already exists on the element.`);
    return;
  }
  element.classList.add(className);
}
function removeClass(element, className, options = {}) {
  if (!(element instanceof HTMLElement)) {
    throw new Error("Invalid element provided.");
  }
  if (typeof className !== "string" || !className.trim()) {
    throw new Error("Invalid className provided.");
  }
  const { logChanges = false, preserveState = false } = options;
  if (preserveState) {
    element.dataset.previousClassList = element.className;
  }
  element.classList.remove(className);
  if (logChanges) {
    console.log(`Class "${className}" removed from element.`);
  }
}
function toggleClass(element, className, options = {}) {
  if (!(element instanceof HTMLElement)) {
    throw new Error("Invalid element provided.");
  }
  if (typeof className !== "string" || !className.trim()) {
    throw new Error("Invalid className provided.");
  }
  const { onAdd, onRemove } = options;
  if (element.classList.toggle(className)) {
    if (typeof onAdd === "function") {
      onAdd(element);
    }
  } else {
    if (typeof onRemove === "function") {
      onRemove(element);
    }
  }
}
function replaceClass(element, oldClass, newClass, options = {}) {
  if (!(element instanceof HTMLElement)) {
    throw new Error("Invalid element provided.");
  }
  if (typeof oldClass !== "string" || !oldClass.trim() || typeof newClass !== "string" || !newClass.trim()) {
    throw new Error("Invalid class names provided.");
  }
  const { enableUndo = false } = options;
  removeClass(element, oldClass);
  addClass(element, newClass);
  if (enableUndo) {
    const undo = () => {
      removeClass(element, newClass);
      addClass(element, oldClass);
      console.log(
        `Undo: Class "${newClass}" replaced back with "${oldClass}".`
      );
    };
    return undo;
  }
  return null;
}
async function addClasses(element, classNames, options = {}) {
  if (!(element instanceof HTMLElement)) {
    throw new Error("Invalid element provided.");
  }
  if (!Array.isArray(classNames) || classNames.some((name) => typeof name !== "string" || !name.trim())) {
    throw new Error("Invalid classNames provided.");
  }
  const { timeout = 0, checkForDuplicates = false } = options;
  if (timeout > 0) {
    await new Promise((resolve) => setTimeout(resolve, timeout));
  }
  classNames.forEach((className) => {
    if (!checkForDuplicates || !element.classList.contains(className)) {
      element.classList.add(className);
    }
  });
}
function replaceClasses(element, classMap) {
  for (const oldClass in classMap) {
    if (classMap.hasOwnProperty(oldClass)) {
      replaceClass(element, oldClass, classMap[oldClass]);
    }
  }
}
function toggleClassConditionally(element, condition, trueClass, falseClass) {
  if (condition) {
    addClass(element, trueClass);
    removeClass(element, falseClass);
  } else {
    addClass(element, falseClass);
    removeClass(element, trueClass);
  }
}
function hasAnyClass(element, classArray) {
  for (const className of classArray) {
    if (typeof className === "string" && element.classList.contains(className)) {
      return true;
    }
  }
  return false;
}
function replaceClassPrefix(element, oldPrefix, newPrefix) {
  const classNames = Array.from(element.classList);
  classNames.forEach((className) => {
    if (className.startsWith(oldPrefix)) {
      removeClass(element, className);
      addClass(element, className.replace(oldPrefix, newPrefix));
    }
  });
}
function addUniqueClass(element, className) {
  if (!element.classList.contains(className)) {
    addClass(element, className);
  }
}
function addClassOnViewportEnter(element, className) {
  const handleScroll = () => {
    const rect = element.getBoundingClientRect();
    if (rect.top >= 0 && rect.bottom <= window.innerHeight) {
      addClass(element, className);
      window.removeEventListener("scroll", handleScroll);
    }
  };
  window.addEventListener("scroll", handleScroll);
  handleScroll();
}
function toggleClassOnFocus(element, className) {
  element.addEventListener("focus", () => {
    addClass(element, className);
  });
  element.addEventListener("blur", () => {
    removeClass(element, className);
  });
}
function toggleClassOnMediaQueryChange(element, className, mediaQuery) {
  const mediaQueryList = window.matchMedia(mediaQuery);
  const handleMediaQueryChange = (event) => {
    if (event.matches) {
      toggleClass(element, className);
    }
  };
  mediaQueryList.addListener(handleMediaQueryChange);
  handleMediaQueryChange(mediaQueryList);
}
function toggleClassOnCopy(element, className) {
  element.addEventListener("copy", () => {
    toggleClass(element, className);
  });
}
function toggleClassOnIdleTime(element, className, idleTime = 3e4) {
  let idleTimer;
  const resetIdleTimer = () => {
    clearTimeout(idleTimer);
    idleTimer = setTimeout(() => {
      toggleClass(element, className);
    }, idleTime);
  };
  document.addEventListener("mousemove", resetIdleTimer);
  document.addEventListener("keypress", resetIdleTimer);
  resetIdleTimer();
}
function addClassOnInterval(element, className, interval = 1e3) {
  setInterval(() => {
    addClass(element, className);
  }, interval);
}
function removeClassOnInterval(element, className, interval = 1e3) {
  setInterval(() => {
    removeClass(element, className);
  }, interval);
}
function toggleClassOnDeviceMotion(element, className) {
  window.addEventListener("deviceorientation", (event) => {
    const tiltThreshold = 20;
    const isTilted = Math.abs(event.beta) > tiltThreshold || Math.abs(event.gamma) > tiltThreshold;
    if (isTilted) {
      toggleClass(element, className);
    }
  });
}
function toggleClassOnOrientationChange(element, className) {
  const handleOrientationChange = () => {
    const orientation = window.matchMedia("(orientation: portrait)").matches ? "portrait" : "landscape";
    toggleClass(element, `${className}-${orientation}`);
  };
  window.addEventListener("orientationchange", handleOrientationChange);
  handleOrientationChange();
}
function toggleClassOnSwipe(element, className) {
  let startX, startY;
  element.addEventListener("touchstart", (event) => {
    startX = event.touches[0].clientX;
    startY = event.touches[0].clientY;
  });
  element.addEventListener("touchend", (event) => {
    const deltaX = event.changedTouches[0].clientX - startX;
    const deltaY = event.changedTouches[0].clientY - startY;
    if (Math.abs(deltaX) > Math.abs(deltaY)) {
      toggleClass(element, `${className}-horizontal`);
    } else {
      toggleClass(element, `${className}-vertical`);
    }
  });
}
function toggleClassOnConnectionStatus(element, trueClass, falseClass) {
  const handleConnectionChange = () => {
    const isOnline = navigator.onLine;
    toggleClassConditionally(element, isOnline, trueClass, falseClass);
  };
  window.addEventListener("online", handleConnectionChange);
  window.addEventListener("offline", handleConnectionChange);
  handleConnectionChange();
}
function toggleClassOnGeolocationChange(element, className, options = {}) {
  if (!(element instanceof HTMLElement)) {
    throw new Error("Invalid element provided.");
  }
  if (typeof className !== "string" || !className.trim()) {
    throw new Error("Invalid className provided.");
  }
  const {
    enableThrottling = true,
    throttleInterval = 5e3,
    onClassToggle = null,
    onError = null,
    geoOptions = {
      enableHighAccuracy: true,
      timeout: 1e4,
      maximumAge: 0
    }
  } = options;
  let lastToggleTime = 0;
  let classToggled = false;
  const toggleClassWithConditions = (position) => {
    const currentTime = Date.now();
    if (enableThrottling && currentTime - lastToggleTime < throttleInterval) {
      console.log("Throttling geolocation updates, skipping toggle.");
      return;
    }
    toggleClass(element, className);
    if (typeof onClassToggle === "function") {
      onClassToggle(position, classToggled);
    }
    classToggled = !classToggled;
    lastToggleTime = currentTime;
  };
  const handleGeolocationError = (error) => {
    console.error("Geolocation error occurred:", error.message);
    if (typeof onError === "function") {
      onError(error);
    }
  };
  const geoWatchId = navigator.geolocation.watchPosition(
    toggleClassWithConditions,
    handleGeolocationError,
    geoOptions
  );
  console.log("Started watching geolocation changes with ID:", geoWatchId);
  return () => {
    navigator.geolocation.clearWatch(geoWatchId);
    console.log("Stopped watching geolocation changes.");
  };
}

// src/modules/class.ts
var ClassUtils = {
  add: addClass,
  addOnInterval: addClassOnInterval,
  addOnViewportEnter: addClassOnViewportEnter,
  addMany: addClasses,
  addUnique: addUniqueClass,
  hasAny: hasAnyClass,
  remove: removeClass,
  removeOnInterval: removeClassOnInterval,
  replace: replaceClass,
  replacePrefix: replaceClassPrefix,
  replaceMany: replaceClasses,
  toggle: toggleClass,
  toggleConditionally: toggleClassConditionally,
  toggleOnConnectionStatus: toggleClassOnConnectionStatus,
  toggleOnCopy: toggleClassOnCopy,
  toggleOnDeviceMotion: toggleClassOnDeviceMotion,
  toggleOnFocus: toggleClassOnFocus,
  toggleOnGeolocationChange: toggleClassOnGeolocationChange,
  toggleOnIdleTime: toggleClassOnIdleTime,
  toggleOnMediaQueryChange: toggleClassOnMediaQueryChange,
  toggleOnOrientationChange: toggleClassOnOrientationChange,
  toggleOnSwipe: toggleClassOnSwipe
};
var class_default = ClassUtils;

// src/core/element.ts
function create(name, options = {}, callback) {
  const element = document.createElement(name);
  if (options.class && Array.isArray(options.class)) {
    options.class.forEach((className) => {
      if (className) {
        element.classList.add(className);
      }
    });
  }
  if (options.attr) {
    for (const key in options.attr) {
      if (Object.hasOwnProperty.call(options.attr, key)) {
        element.setAttribute(key, options.attr[key]);
      }
    }
  }
  if (options.innerText) element.innerText = options.innerText;
  if (options.innerHTML) element.innerHTML = options.innerHTML;
  if (options.children && Array.isArray(options.children)) {
    options.children.forEach((child) => {
      if (child instanceof HTMLElement) {
        element.appendChild(child);
      }
    });
  }
  if (options.draggable) element.draggable = true;
  if (options.style) element.style.cssText = options.style;
  if (options.trackMutation) {
    const observer = new MutationObserver((mutations) => {
      mutations.forEach((mutation) => {
        console.log("Mutation observed:", mutation);
      });
    });
    observer.observe(element, {
      attributes: true,
      childList: true,
      subtree: true
    });
  }
  if (callback && typeof callback === "function") callback(element);
  return element;
}
function setHTML(element, htmlContent, evaluateScripts = false) {
  element.innerHTML = htmlContent;
  if (evaluateScripts) {
    const scripts = element.querySelectorAll("script");
    scripts.forEach((script2) => {
      const newScript = document.createElement("script");
      if (script2.src) {
        newScript.src = script2.src;
      } else {
        newScript.textContent = script2.textContent;
      }
      script2.replaceWith(newScript);
    });
  }
}
function getHTML(element) {
  const tempDiv = create("div", { innerHTML: element.innerHTML });
  tempDiv.querySelectorAll("script, iframe, link").forEach((node) => node.remove());
  return tempDiv.innerHTML;
}
function setText(element, textContent, options = {}) {
  if (options.toUpperCase) {
    textContent = textContent.toUpperCase();
  }
  if (options.toLowerCase) {
    textContent = textContent.toLowerCase();
  }
  element.textContent = textContent;
}

// src/utils/create-helper.ts
function setAttributeOrChildren(element, ...attributesOrChildren) {
  attributesOrChildren.forEach((item) => {
    if (typeof item === "object" && !(item instanceof HTMLElement)) {
      setAttribute(element, item);
    } else if (item instanceof HTMLElement || typeof item === "string") {
      element.append(item);
    }
  });
}

// src/core/html.ts
var tags = [
  "button",
  "span",
  "div",
  "a",
  "p",
  "h1",
  "h2",
  "h3",
  "h4",
  "h5",
  "h6",
  "ul",
  "ol",
  "li",
  "img",
  "input",
  "form",
  "table",
  "tr",
  "td",
  "th",
  "tbody",
  "thead",
  "tfoot",
  "textarea",
  "select",
  "option",
  "section",
  "article",
  "aside",
  "header",
  "footer",
  "nav",
  "main",
  "figure",
  "figcaption",
  "audio",
  "video",
  "source",
  "canvas",
  "details",
  "summary",
  "datalist",
  "fieldset",
  "legend",
  "label",
  "meter",
  "progress",
  "time",
  "output",
  "iframe",
  "object",
  "embed",
  "picture",
  "track",
  "map",
  "area",
  "base",
  "link",
  "style",
  "script",
  "title",
  "meta",
  "abbr",
  "bdi",
  "dialog",
  "mark"
];
function createElementWithAttributes(tag, ...attributesOrChildren) {
  const element = create(tag);
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}
var elements = Object.fromEntries(
  tags.map((tag) => [
    tag,
    (...attributesOrChildren) => createElementWithAttributes(tag, ...attributesOrChildren)
  ])
);
function custom(name, ...attributesOrChildren) {
  const element = create(name);
  setAttributeOrChildren(element, ...attributesOrChildren);
  return element;
}
function body(...attributesOrChildren) {
  setAttributeOrChildren(document.body, ...attributesOrChildren);
  return document.body;
}
function head(...attributesOrChildren) {
  setAttributeOrChildren(document.head, ...attributesOrChildren);
  return document.head;
}
var button = elements.button;
var span = elements.span;
var div = elements.div;
var a = elements.a;
var p = elements.p;
var h1 = elements.h1;
var h2 = elements.h2;
var h3 = elements.h3;
var h4 = elements.h4;
var h5 = elements.h5;
var h6 = elements.h6;
var ul = elements.ul;
var ol = elements.ol;
var li = elements.li;
var img = elements.img;
var input = elements.input;
var form = elements.form;
var table = elements.table;
var tr = elements.tr;
var td = elements.td;
var th = elements.th;
var tbody = elements.tbody;
var thead = elements.thead;
var tfoot = elements.tfoot;
var textarea = elements.textarea;
var select = elements.select;
var option = elements.option;
var section = elements.section;
var article = elements.article;
var aside = elements.aside;
var header = elements.header;
var footer = elements.footer;
var nav = elements.nav;
var main = elements.main;
var figure = elements.figure;
var figcaption = elements.figcaption;
var audio = elements.audio;
var video = elements.video;
var source = elements.source;
var canvas = elements.canvas;
var details = elements.details;
var summary = elements.summary;
var datalist = elements.datalist;
var fieldset = elements.fieldset;
var legend = elements.legend;
var label = elements.label;
var meter = elements.meter;
var progress = elements.progress;
var time = elements.time;
var output = elements.output;
var iframe = elements.iframe;
var object = elements.object;
var embed = elements.embed;
var picture = elements.picture;
var track = elements.track;
var map = elements.map;
var area = elements.area;
var base = elements.base;
var link = elements.link;
var style = elements.style;
var script = elements.script;
var title = elements.title;
var meta = elements.meta;
var abbr = elements.abbr;
var bdi = elements.bdi;
var dialog = elements.dialog;
var mark = elements.mark;

// src/modules/element.ts
var Element = {
  create,
  getHTML,
  setHTML,
  setText
};
var element_default = Element;

// src/utils/event.ts
var eventStore = /* @__PURE__ */ new Map();
var dataStore = /* @__PURE__ */ new Map();

// src/core/event.ts
function on(element, event, handler) {
  if (!eventStore.has(element)) {
    eventStore.set(element, /* @__PURE__ */ new Map());
  }
  const eventMap = eventStore.get(element);
  if (!eventMap.has(event)) {
    eventMap.set(event, []);
  }
  eventMap.get(event).push(handler);
  element.addEventListener(event, handler);
}
function off(element, event, handler) {
  const eventMap = eventStore.get(element);
  if (eventMap && eventMap.has(event)) {
    const handlers = eventMap.get(event);
    const index = handlers.indexOf(handler);
    if (index > -1) {
      handlers.splice(index, 1);
      element.removeEventListener(event, handler);
    }
  }
}
function trigger(element, event) {
  const customEvent = new Event(event, { bubbles: true, cancelable: true });
  element.dispatchEvent(customEvent);
}
function once(element, event, handler) {
  const onceHandler = (e) => {
    handler(e);
    off(element, event, onceHandler);
  };
  on(element, event, onceHandler);
}
function delegate(parent, childSelector, event, handler) {
  const delegateHandler = (e) => {
    const target = e.target;
    if (target && target.matches(childSelector)) {
      handler(e);
    }
  };
  on(parent, event, delegateHandler);
}
function setEventData(event, data) {
  dataStore.set(event, data);
}
function getEventData(event) {
  return dataStore.get(event);
}
function triggerEvent(element, eventType, options) {
  const customEvent = new CustomEvent(eventType, {
    bubbles: true,
    cancelable: true,
    ...options
  });
  element.dispatchEvent(customEvent);
}

// src/modules/event.ts
var EventUtils = {
  delegate,
  getEventData,
  off,
  on,
  once,
  setEventData,
  trigger,
  triggerEvent
};
var event_default = EventUtils;

// src/core/traverse.ts
function selectElem(selector, options) {
  const elements2 = Array.from(document.querySelectorAll(selector));
  let filteredElements = elements2;
  if (options?.attribute && options.value) {
    filteredElements = filteredElements.filter(
      (element) => element.getAttribute(options.attribute) === options.value
    );
  }
  if (options?.className) {
    filteredElements = filteredElements.filter(
      (element) => element.classList.contains(options.className)
    );
  }
  if (options?.tagName) {
    filteredElements = filteredElements.filter(
      (element) => element.tagName.toLowerCase() === options.tagName.toLowerCase()
    );
  }
  if (options?.customAttributes) {
    for (const [attr, val] of Object.entries(options.customAttributes)) {
      filteredElements = filteredElements.filter(
        (element) => element.getAttribute(attr) === val
      );
    }
  }
  if (options?.dataAttributes) {
    for (const [dataAttr, val] of Object.entries(options.dataAttributes)) {
      filteredElements = filteredElements.filter(
        (element) => element.dataset[dataAttr] === val
      );
    }
  }
  if (options?.innerText) {
    filteredElements = filteredElements.filter(
      (element) => element.textContent?.includes(options.innerText) || false
    );
  }
  if (options?.innerHTML) {
    filteredElements = filteredElements.filter(
      (element) => element.innerHTML.includes(options.innerHTML)
    );
  }
  if (options?.hasChild) {
    filteredElements = filteredElements.filter(
      (element) => element.querySelector(options.hasChild) !== null
    );
  }
  if (options?.filterCallback) {
    filteredElements = filteredElements.filter(options.filterCallback);
  }
  if (options?.orderBy) {
    filteredElements.sort((a2, b) => {
      const aValue = a2.textContent || "";
      const bValue = b.textContent || "";
      return options.orderBy === "asc" ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
    });
  }
  if (options?.limit) {
    filteredElements = filteredElements.slice(0, options.limit);
  }
  if (options?.multiple) {
    return filteredElements.length > 0 ? filteredElements : null;
  } else {
    return filteredElements.length > 0 ? filteredElements[0] : null;
  }
}
function getParent(element, options) {
  if (!element) throw new Error("Element cannot be null or undefined.");
  let parent = element.parentNode;
  if (options?.includeDocument && parent === document) {
    return document;
  }
  return parent;
}
function getChildren(element, options) {
  if (!element) throw new Error("Element cannot be null or undefined.");
  const children = Array.from(element.children);
  return options?.filter ? children.filter(options.filter) : children;
}
function getNextSibling(element, options) {
  if (!element) throw new Error("Element cannot be null or undefined.");
  let sibling = element.nextElementSibling;
  while (sibling && options?.skipHidden && !sibling.offsetWidth && !sibling.offsetHeight) {
    sibling = sibling.nextElementSibling;
  }
  return sibling ? sibling : null;
}
function getPreviousSibling(element, options) {
  if (!element) throw new Error("Element cannot be null or undefined.");
  let sibling = element.previousElementSibling;
  while (sibling && options?.skipHidden && !sibling.offsetWidth && !sibling.offsetHeight) {
    sibling = sibling.previousElementSibling;
  }
  return sibling ? sibling : null;
}
function getClosest(element, selector, options) {
  if (!element) throw new Error("Element cannot be null or undefined.");
  let current = element;
  while (current && current !== options?.stopAt) {
    if (current.matches(selector)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function findAll(element, selector, options) {
  if (!element) throw new Error("Element cannot be null or undefined.");
  let foundElements = Array.from(element.querySelectorAll(selector));
  if (options?.unique) {
    foundElements = Array.from(new Set(foundElements));
  }
  if (options?.limit && options.limit < foundElements.length) {
    return foundElements.slice(0, options.limit);
  }
  return foundElements;
}

// src/modules/traverse.ts
var Traverse = {
  findAll,
  getChildren,
  getClosest,
  getNextSibling,
  getParent,
  getPreviousSibling,
  select: selectElem
};
var traverse_default = Traverse;
export {
  attribute_default as Attribute,
  class_default as ClassUtils,
  element_default as Element,
  event_default as EventUtils,
  traverse_default as Traverse,
  a,
  abbr,
  addClass,
  addClassOnInterval,
  addClassOnViewportEnter,
  addClasses,
  addUniqueClass,
  area,
  article,
  aside,
  attributesToQueryString,
  audio,
  base,
  bdi,
  body,
  button,
  canvas,
  compareAttributes,
  copyAttributes,
  create,
  custom,
  datalist,
  delegate,
  details,
  dialog,
  div,
  embed,
  fieldset,
  figcaption,
  figure,
  findAll,
  findElementByAttribute,
  footer,
  form,
  getAllAttributes,
  getAttribute,
  getAttributesByPrefix,
  getChildren,
  getClosest,
  getEventData,
  getHTML,
  getNextSibling,
  getParent,
  getPreviousSibling,
  h1,
  h2,
  h3,
  h4,
  h5,
  h6,
  hasAnyAttributes,
  hasAnyClass,
  hasAttribute,
  head,
  header,
  iframe,
  img,
  input,
  label,
  legend,
  li,
  link,
  main,
  map,
  mark,
  meta,
  meter,
  nav,
  object,
  off,
  ol,
  on,
  once,
  option,
  output,
  p,
  picture,
  progress,
  removeAllAttributes,
  removeAttribute,
  removeAttributesByName,
  removeAttributesByPrefix,
  removeClass,
  removeClassOnInterval,
  replaceClass,
  replaceClassPrefix,
  replaceClasses,
  script,
  section,
  select,
  selectElem,
  setAttribute,
  setAttributesFromQueryString,
  setEventData,
  setHTML,
  setText,
  source,
  span,
  style,
  summary,
  table,
  tbody,
  td,
  textarea,
  tfoot,
  th,
  thead,
  time,
  title,
  toggleAttribute,
  toggleAttributes,
  toggleClass,
  toggleClassConditionally,
  toggleClassOnConnectionStatus,
  toggleClassOnCopy,
  toggleClassOnDeviceMotion,
  toggleClassOnFocus,
  toggleClassOnGeolocationChange,
  toggleClassOnIdleTime,
  toggleClassOnMediaQueryChange,
  toggleClassOnOrientationChange,
  toggleClassOnSwipe,
  tr,
  track,
  trigger,
  triggerEvent,
  ul,
  video
};
