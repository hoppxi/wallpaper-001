// src/core/traverse.ts
function selectElem(selector, options) {
  const elements = Array.from(document.querySelectorAll(selector));
  let filteredElements = elements;
  if (options?.attribute && options.value) {
    filteredElements = filteredElements.filter(
      (element) => element.getAttribute(options.attribute) === options.value
    );
  }
  if (options?.className) {
    filteredElements = filteredElements.filter(
      (element) => element.classList.contains(options.className)
    );
  }
  if (options?.tagName) {
    filteredElements = filteredElements.filter(
      (element) => element.tagName.toLowerCase() === options.tagName.toLowerCase()
    );
  }
  if (options?.customAttributes) {
    for (const [attr, val] of Object.entries(options.customAttributes)) {
      filteredElements = filteredElements.filter(
        (element) => element.getAttribute(attr) === val
      );
    }
  }
  if (options?.dataAttributes) {
    for (const [dataAttr, val] of Object.entries(options.dataAttributes)) {
      filteredElements = filteredElements.filter(
        (element) => element.dataset[dataAttr] === val
      );
    }
  }
  if (options?.innerText) {
    filteredElements = filteredElements.filter(
      (element) => element.textContent?.includes(options.innerText) || false
    );
  }
  if (options?.innerHTML) {
    filteredElements = filteredElements.filter(
      (element) => element.innerHTML.includes(options.innerHTML)
    );
  }
  if (options?.hasChild) {
    filteredElements = filteredElements.filter(
      (element) => element.querySelector(options.hasChild) !== null
    );
  }
  if (options?.filterCallback) {
    filteredElements = filteredElements.filter(options.filterCallback);
  }
  if (options?.orderBy) {
    filteredElements.sort((a, b) => {
      const aValue = a.textContent || "";
      const bValue = b.textContent || "";
      return options.orderBy === "asc" ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
    });
  }
  if (options?.limit) {
    filteredElements = filteredElements.slice(0, options.limit);
  }
  if (options?.multiple) {
    return filteredElements.length > 0 ? filteredElements : null;
  } else {
    return filteredElements.length > 0 ? filteredElements[0] : null;
  }
}
function getParent(element, options) {
  if (!element) throw new Error("Element cannot be null or undefined.");
  let parent = element.parentNode;
  if (options?.includeDocument && parent === document) {
    return document;
  }
  return parent;
}
function getChildren(element, options) {
  if (!element) throw new Error("Element cannot be null or undefined.");
  const children = Array.from(element.children);
  return options?.filter ? children.filter(options.filter) : children;
}
function getNextSibling(element, options) {
  if (!element) throw new Error("Element cannot be null or undefined.");
  let sibling = element.nextElementSibling;
  while (sibling && options?.skipHidden && !sibling.offsetWidth && !sibling.offsetHeight) {
    sibling = sibling.nextElementSibling;
  }
  return sibling ? sibling : null;
}
function getPreviousSibling(element, options) {
  if (!element) throw new Error("Element cannot be null or undefined.");
  let sibling = element.previousElementSibling;
  while (sibling && options?.skipHidden && !sibling.offsetWidth && !sibling.offsetHeight) {
    sibling = sibling.previousElementSibling;
  }
  return sibling ? sibling : null;
}
function getClosest(element, selector, options) {
  if (!element) throw new Error("Element cannot be null or undefined.");
  let current = element;
  while (current && current !== options?.stopAt) {
    if (current.matches(selector)) {
      return current;
    }
    current = current.parentElement;
  }
  return null;
}
function findAll(element, selector, options) {
  if (!element) throw new Error("Element cannot be null or undefined.");
  let foundElements = Array.from(element.querySelectorAll(selector));
  if (options?.unique) {
    foundElements = Array.from(new Set(foundElements));
  }
  if (options?.limit && options.limit < foundElements.length) {
    return foundElements.slice(0, options.limit);
  }
  return foundElements;
}

// src/modules/traverse.ts
var Traverse = {
  findAll,
  getChildren,
  getClosest,
  getNextSibling,
  getParent,
  getPreviousSibling,
  select: selectElem
};
var traverse_default = Traverse;
export {
  traverse_default as default,
  findAll,
  getChildren,
  getClosest,
  getNextSibling,
  getParent,
  getPreviousSibling,
  selectElem
};
